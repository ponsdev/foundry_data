const e="lib-wrapper";let t="",r=-1,i=-1,n=-1,a=-1,s="";const o="undefined"==typeof Game,c=!!o;let l=!1;const p=["WRAPPER","MIXED","OVERRIDE"];Object.freeze(p);const d={WRAPPER:1,MIXED:2,OVERRIDE:3};Object.freeze(d);const h={};for(let e in d)h[d[e]]=e;Object.freeze(h);const _=["STANDARD","AUTO","FAST"];Object.freeze(_);const u={STANDARD:1,AUTO:2,FAST:3};Object.freeze(u);const f={};for(let e in u)f[u[e]]=e;Object.freeze(f);const g=eval;function w(e,t){try{e.displayName=t,Object.defineProperty(e,"name",{value:t,writable:!1,enumerable:!1,configurable:!0})}catch(e){if(o)throw e}}function m(e,t=""){return""!==t?`🎁${e}#${t}`:`🎁${e}`}function b(e){const t=Object.getOwnPropertyNames(e);t.push(...Object.getOwnPropertySymbols(e));for(const r of t){const t=Object.getOwnPropertyDescriptor(e,r);"function"==typeof t.value&&w(t.value,m(r)),"function"==typeof t.get&&w(t.get,m(r,"getter")),"function"==typeof t.set&&w(t.set,m(r,"setter"))}e.prototype&&b(e.prototype)}const y=new Set;function k(e){throw globalThis.libWrapper?new globalThis.libWrapper.LibWrapperInternalError(e):new Error(e)}const O=function(e=!1){const t=game?.user?.data;if(t)return t;const r=game.userId??game.data.userId;if(!r){if(e)return null;k("Unable to obtain the current user ID")}const i=game.data.users.find((e=>e._id==r));if(!i){if(e)return null;k("Unable to obtain the current user data object")}return i};class E{static init(){}static get ui_notifications_enabled(){try{if(function(e=!1){const t=game?.user?.isGM;if(void 0!==t)return t;const r=O(e);return r?4===r.role:null}()){if(!game?.settings?.get(e,"notify-issues-gm"))return!1}else if(!game?.settings?.get(e,"notify-issues-player"))return!1}catch(e){return console.error("libWrapper: Could not decide whether to show notifications or not. Defaulting to 'yes'.\n",e),!0}return!0}static _ui(e,t){if(!this.ui_notifications_enabled)return;if(this.NOTIFICATION_SET){if(this.NOTIFICATION_SET.has(e))return}else this.NOTIFICATION_SET=new Set;this.NOTIFICATION_SET.add(e);let r=globalThis?.ui?.notifications;r&&r[t].call(r,`libWrapper: ${e}`,{permanent:"error"==t})}static ui(e,t="error"){globalThis.game?.ready?this._ui(e,t):Hooks.once("ready",this._ui.bind(this,e,t))}static console_ui(e,t,r="error",...i){console[r].call(console,`libWrapper: ${e}\n${t}`,...i),this.ui(`${e} (See JS console)`,r)}static conflict(e,t,r,i){let n;n=Array.isArray(t)?t.length>1?`[${t.map((e=>e.id)).join(", ")}]`:t[0].logString:t.logString,this.console_ui(r?`Potential conflict detected between ${e.logString} and ${n}.`:`Conflict detected between ${e.logString} and ${n}.`,i,r?"warn":"error")}}b(E);const S={UNKNOWN:0,MODULE:1,SYSTEM:2,WORLD:3};Object.freeze(S);const W={};for(let e in S)W[S[e]]=e;Object.freeze(W);class v{constructor(e=null,t=null){this.set(e,t)}set(e=null,t=null,r=!0){if(!e)return this.detect_id();if("string"!=typeof e)throw"libWrapper: PackageInfo IDs must be strings";if(e.indexOf("~")>=0)return this.from_key(e);this.id=e,this.type=t,t||this.detect_type(),r&&Object.freeze(this)}set_unknown(){this.id="«unknown»",this.type=S.UNKNOWN}equals(e){return e&&e.constructor===this.constructor&&e.id===this.id&&e.type===this.type}detect_id(t){if(this.set_unknown(),void 0===t){const e=Error.stackTraceLimit;if(Error.stackTraceLimit=1/0,t=Error().stack,Error.stackTraceLimit=e,!t)return}const r=t.matchAll(/\/(worlds|systems|modules)\/(.+?)(?=\/)/gi);if(r)for(let t of r){const r=t[1],i=t[2];if("worlds"===r){if(i==game.data.world.id)return this.set(i,S.WORLD)}else{if("systems"!==r){if("modules"===r){if(!i||i==e||!game?.modules?.has(i))continue;return this.set(i,S.MODULE)}throw new Error(`libWrapper: Invalid script type: ${r}`)}if(i==game.data.system.id)return this.set(i,S.SYSTEM)}}}detect_type(){game?.modules?game.modules.get(this.id)?.active?this.type=S.MODULE:this.id===game.data.system.id?this.type=S.SYSTEM:this.id===game.data.world.id?this.type=S.WORLD:this.type=S.UNKNOWN:this.id===e?this.type=S.MODULE:this.type=S.UNKNOWN}get known(){return this.type!=S.UNKNOWN}get exists(){switch(this.type){case S.MODULE:return game.modules.get(this.id)?.active;case S.SYSTEM:return game.data.system.id===this.id;case S.WORLD:return game.data.world.id===this.id;default:return!1}}get data(){if(!this.exists)return null;switch(this.type){case S.MODULE:return game.modules.get(this.id)?.data;case S.SYSTEM:return game.data.system.data;case S.WORLD:return game.data.world;default:return null}}get title(){if(!this.exists)return"Unknown";switch(this.type){case S.MODULE:case S.SYSTEM:case S.WORLD:return this.data.title;default:return"Unknown"}}get key(){return`${W[this.type].toLowerCase()}~${this.id}`}from_key(e){const t=e.split("~");if(2!==t.length)throw`Error: Invalid key '${e}'`;this.set(t[1],S[t[0]])}get logString(){return this.known?`${W[this.type].toLowerCase()} '${this.id}'`:"an unknown package"}get logStringCapitalized(){let e=this.logString;return e.charAt(0).toUpperCase()+e.slice(1)}get settingsName(){switch(this.type){case S.MODULE:return this.id;case S.SYSTEM:return`${this.id} [System]`;case S.WORLD:return`${this.id} [World]`;default:return this.id}}}Object.freeze(v);class T{static _collect_stats(){try{return function(e,t=!1){const r=game?.user?.can;if(r)return r(e);const i=O(t);if(!i)return null;if(4===i.role)return!0;if(e in i.permissions)return i.permissions[e];const n=game.data.settings.find((e=>"core.permissions"===e.key));if(n?.value){const t=JSON.parse(n.value)[e];if(t&&t.includes(i.role))return!0}return!1}("SETTINGS_MODIFY")}catch(e){if(o)throw e;return E.console_ui("A non-critical error occurred while initializing libWrapper.","Could not read user permissions during initialization.\n","warn",e),!0}}static init(){this.collect_stats=this._collect_stats(),this.collect_stats&&(this.PACKAGES=new Set,this.CONFLICTS=new Map)}static register_package(t){this.collect_stats&&t.id!=e&&this.PACKAGES.add(t.key)}static register_conflict(e,t,r){if(!this.collect_stats)return;if(!t)return;if(Array.isArray(t)){let i=!1;return t.forEach((t=>{i|=T.register_conflict(e,t,r)})),i}if(!1===Hooks.call("libWrapper.ConflictDetected",e.id,t.id,r))return console.debug(`Conflict between ${e.logString} and ${t.logString} over '${r}' ignored, as 'libWrapper.ConflictDetected' hook returned false.`),!1;const i=`${e.key}/${t.key}`;let n=this.CONFLICTS.get(i);return n||(n={count:0,package_info:e,other_info:t,targets:new Map},this.CONFLICTS.set(i,n)),n.count++,n.targets.set(r,(n.targets.get(r)??0)+1),!0}static get conflicts(){return this.CONFLICTS}static get packages(){return this.PACKAGES}}class A extends Error{constructor(e,t,r,...i){super(`${e}\n${t}`,...i),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.ui_msg=e,this.console_msg=t,this.notification_fn=r??"error"}onUnhandled(){}}Object.freeze(A);class I extends A{constructor(e,...t){const r=new v;super(r.known?`Internal error detected, possibly related to ${r.logString}.`:"Internal error detected.",e,"error",...t),this.package_info=r}get package_id(){return this.package_info?.id}get module(){return this.package_id}}Object.freeze(I);class C extends A{constructor(e,t,...r){let i=!1;t?t?.constructor!==v&&(t=new v(t)):(t=new v,i=!0),super(i?`Error detected, possibly in ${t.logString}.`:`Error detected in ${t.logString}.`,e,"error",...r),this.package_info=t}get package_id(){return this.package_info?.id}get module(){return this.package_id}}Object.freeze(C);class j extends A{constructor(e,t,r,...i){e?.constructor!==v&&(e=new v(e)),t?.constructor!==v&&(t=new v(t)),super(`Conflict detected between ${e.logString} and ${t.logString}.`,`Failed to wrap '${r}' for ${e.logString} with type OVERRIDE. An OVERRIDE wrapper for the same method has already been registered by ${t.logString}.`,"error",...i),this.package_info=e,this.conflicting_info=t,this.target=r}get package_id(){return this.package_info?.id}get module(){return this.package_id}get conflicting_id(){return this.conflicting_info?.id}get conflicting_module(){return this.conflicting_id}onUnhandled(){super.onUnhandled(),T.register_conflict(this.package_info,this.conflicting_info,this.target)}}Object.freeze(j);class N extends A{constructor(e,t,r,...i){t?.constructor!==v&&(t=new v(t)),super(`Error detected in '${t.logString}'.`,r,"error",...i),this._wrapper=e,this.package_info=t}get package_id(){return this.package_info?.id}get module(){return this.package_id}}Object.freeze(N);const z=function(e){try{const t=e.reason??e.error??e;if(!(t&&t instanceof A))return;t.ui_msg&&t.notification_fn&&E.ui(`${t.ui_msg} (See JS console)`,t.notification_fn),t.onUnhandled&&t.onUnhandled.apply(t)}catch(e){console.warn("libWrapper: Exception thrown while processing an unhandled exception.",e)}};class U{get name(){return this.names[0]}_callstack_name(e,t=this.name){return m(t,e)}constructor(e,t,r,i){this.fn_name=t,this.object=e;let n=Object.getOwnPropertyDescriptor(e,t);if(n){if(n.get?._lib_wrapper){let e=n.get?._lib_wrapper;if(r&&!e.names.indexOf(r)&&e.names.push(r),e&&e instanceof this.constructor)return e}if(!1===n.configurable)throw new C(`libWrapper: '${r}' cannot be wrapped, the corresponding descriptor has 'configurable=false'.`,i);n.get?(this.is_property=!0,this._wrapped_getter=n.get,this._wrapped_setter=n.set):(this.is_property=!1,this._wrapped=n.value)}else{if(n=this._get_inherited_descriptor(),!n)throw new C(`libWrapper: Can't wrap '${r}', target does not exist or could not be found.`,i);const e=n.get?._lib_wrapper;e?this.is_property=e.is_property:n.get??n.set?this.is_property=!0:this.is_property=!1}this.names=[],this.getter_data=[],this._getter_data_id=0,this.is_property&&(this.setter_data=[],this._setter_data_id=0),this.active=!1,this._outstanding_wrappers=0,this._current_handler_id=0,this.is_property||(this._pending_wrapped_calls=[],this._pending_wrapped_calls_cnt=0),this.update_use_static_dispatch(),r||(r=t),-1==this.names.indexOf(r)&&this.names.push(r),this._wrap()}_get_handler(){const e=this._current_handler_id;if(e===this._cached_handler_id)return this._cached_handler;const t=this,r=this._callstack_name(e),i=this._wrapped,n={[r]:function(...r){const n=t.use_static_dispatch;return t.should_skip_wrappers(this,e,n)?t.get_wrapped(this,!1,i).apply(this,r):n?t.get_static_dispatch_chain(this).apply(this,r):t.call_wrapper(null,this,...r)},toString:function(){return t.get_wrapped(this).toString()}},a=n[r];return a.toString=n.toString,this._cached_handler=a,this._cached_handler_id=e,a}get_static_dispatch_chain(e){const t=this._getter_data_id;let r=null;if(t===this._cached_static_dispatch_chain_id&&e===this._cached_static_dispatch_chain_obj)r=this._cached_static_dispatch_chain;else{const i=()=>{r=this.call_wrapped.bind(this,null,e)},n=this.get_fn_data(!1);for(let t=n.length-1;t>=0;t--){const a=n[t],s=a.fn;a.chain?(r||i(),r=s.bind(e,r)):r=s.bind(e)}r||i(),this._cached_static_dispatch_chain_obj=e,this._cached_static_dispatch_chain_id=t,this._cached_static_dispatch_chain=r}return r}should_skip_wrappers(e,t,r){if(t==this._current_handler_id)return!1;if(t>this._current_handler_id)throw new I(`Unreachable: handler_id=${t} > this._current_handler_id=${this._current_handler_id}`);if(!this.is_property){if(this._pending_wrapped_calls_cnt<=0)return!1;if(!r){if(this._pending_wrapped_calls.indexOf(e)<0)return!1}}return!0}skip_existing_handlers(){this._current_handler_id++}_calc_use_static_dispatch(){const t=this.get_fn_data(!1);let r;for(const e of t)if(e.perf_mode)if(void 0===r)r=e.perf_mode;else if(r!==e.perf_mode){r=u.AUTO;break}return r===u.FAST||r!==u.SAFE&&!!game?.settings?.get(e,"high-performance-mode")}update_use_static_dispatch(){this.use_static_dispatch=this._calc_use_static_dispatch()}_wrap(){if(this.active)return;const e=this._callstack_name("getter"),t=this._callstack_name("setter");let r;if(this.is_property){const i=this;r={[e]:function(...e){return i.call_wrapper(null,this,...e)},[t]:function(...e){return i.call_wrapper({setter:!0},this,...e)}}}else{const i=this;r={[e]:()=>i._get_handler(),[t]:function(e){return i.set_nonproperty(e,this)}}}const i=r[e],n=r[t];i._lib_wrapper=this,Object.defineProperty(this.object,this.fn_name,{get:i,set:n,configurable:c}),this.active=!0,console.debug(`libWrapper: Wrapped '${this.name}'.`)}unwrap(){if(this.active){if(!c)throw new I("libWrapper: Cannot unwrap when PROPERTIES_CONFIGURABLE==false");delete this.object[this.fn_name],this.is_property?Object.defineProperty(this.object,this.fn_name,{get:this._wrapped_getter,set:this._wrapped_setter,configurable:!0}):this.object[this.fn_name]=this._wrapped,this.active=!1,console.debug(`libWrapper: Unwrapped '${this.name}'.`)}}_get_inherited_descriptor(){let e=Object.getPrototypeOf(this.object),t=null;for(;e;){if(t=Object.getOwnPropertyDescriptor(e,this.fn_name),t)return t;e=Object.getPrototypeOf(e)}return null}get_wrapped(e,t=!1,r=this._wrapped){let i;if(i=this.is_property?t?this._wrapped_setter:this._wrapped_getter:r,void 0===i){const r=this._get_inherited_descriptor();if(r)if(this.is_property){if(r.get??!r.set)throw new I("This wrapper is set up to wrap a property, but the inherited descriptor is a method.");i=t?r.set:r.get}else i=r.value??r.get.apply(e)}return void 0===i&&console.warn(`libWrapper: There is no wrapped method for '${this.name}', returning 'undefined'.`),i}call_wrapped(e,t,...r){e&&this._call_wrapper_update_state(e);const i=e?.setter??!1,n=!!e;let a,s;this.is_property||(this._pending_wrapped_calls_cnt++,n&&(a=t,this._pending_wrapped_calls.push(a)));try{s=this.get_wrapped(this.object,i)?.apply(t,r)}catch(e){throw this.is_property||this._cleanup_call_wrapped(a,n),e}return this.is_property||("function"==typeof s?.then?s=s.then((e=>(this._cleanup_call_wrapped(a,n),e)),(e=>{throw this._cleanup_call_wrapped(a,n),e})):this._cleanup_call_wrapped(a,n)),s}_cleanup_call_wrapped(e,t){if(!this._pending_wrapped_calls_cnt)throw new I(`this._pending_wrapped_calls_cnt=${this._pending_wrapped_calls_cnt} should be unreachable at this point.`);if(this._pending_wrapped_calls_cnt--,t){const t=this._pending_wrapped_calls.indexOf(e);if(t<0)throw new I("Could not find 'pend' inside 'this._pending_wrapped_calls'.");this._pending_wrapped_calls.splice(t,1)}}call_wrapper(e,t,...r){e&&this._call_wrapper_update_state(e);const i=e?.index??0,n=e?.setter??!1,a=e?.fn_data??this.get_fn_data(n),s=a[i];if(!s){if(a.length>0)throw new I(`Must not have 'data===${s}' when 'fn_data.length==${a.length}'.`);return this.call_wrapped(null,t,...r)}const o=s.fn;if(!s.chain)return o.apply(t,r);const c=i+1,l=c>=a.length,p={index:c,called:!1,valid:!0,setter:n,prev_data:s,fn_data:a},d=l?this.call_wrapped.bind(this,p,t):this.call_wrapper.bind(this,p,t);let h;this._outstanding_wrappers++;try{h=o.call(t,d,...r)}catch(e){return this._cleanup_call_wrapper_thrown(p,e)}return h="function"==typeof h?.then?h.then((e=>this._cleanup_call_wrapper(e,p,s,a,d,t,r)),(e=>this._cleanup_call_wrapper_thrown(p,e))):this._cleanup_call_wrapper(h,p,s,a,d,t,r),h}_call_wrapper_update_state(e){if("valid"in e&&!e.valid)throw new N(this,e.prev_data?.package_info,`This wrapper function for '${this.name}' is no longer valid, and must not be called.`);e.called=!0}_invalidate_state(e){if(e.valid=!1,this._outstanding_wrappers--,this._outstanding_wrappers<0)throw new I(`Outstanding wrappers = ${this._outstanding_wrappers}, should never fall below 0.`)}_cleanup_call_wrapper_thrown(e,t){throw this._invalidate_state(e),t}_cleanup_call_wrapper(e,t,r,i,n,a,s){try{if(!t.called){let o=!r.warned_conflict||T.collect_stats,c=null,l=!1;o&&(c=i.slice(t.index).filter((e=>!e.package_info.equals(r.package_info))).map((e=>e.package_info)),l=0==c.length,c.length>0&&T.register_conflict(r.package_info,c,this.name)),r.type==d.WRAPPER?(E.console_ui(`Error detected in ${r.package_info.logString}.`,`The wrapper for '${r.target}' registered by ${r.package_info.logString} with type WRAPPER did not chain the call to the next wrapper, which breaks a libWrapper API requirement. This wrapper will be unregistered.`,"error"),globalThis.libWrapper.unregister(r.package_info.id,r.target),l||(e=n.apply(a,s))):r.warned_conflict||l||(E.conflict(r.package_info,c,!0,`${r.package_info.logStringCapitalized} did not chain the wrapper for '${r.target}'.`),r.warned_conflict=!0)}}finally{this._invalidate_state(t)}return e}set_nonproperty(e,t=null){if(this.is_property)throw new I("Must not call 'set_nonproperty' for a property wrapper.");t!==this.object?Object.defineProperty(t,this.fn_name,{value:e,configurable:!0,enumerable:!0,writable:!0}):(this._wrapped=e,this.skip_existing_handlers(),this.warn_classic_wrapper())}get_affected_packages(){return this.getter_data.map((e=>e.package_info))}warn_classic_wrapper(){const e=new v,t=this.get_affected_packages();if(t.length>0){T.register_conflict(e,t,this.name)&&(E.conflict(e,t,!0,`Detected non-libWrapper wrapping of '${this.name}' by ${e.logString}. This will potentially lead to conflicts.`),l&&console.trace&&console.trace())}this.detected_classic_wrapper||(this.detected_classic_wrapper=[]),this.detected_classic_wrapper.push(e.key)}get_fn_data(e,t=!1){if(e&&!this.is_property)throw new I(`libWrapper: '${this.name}' does not wrap a property, thus setter=true is illegal.`);const r=e?"setter_data":"getter_data";let i=this[r];return t&&(this._outstanding_wrappers>0&&(i=this[r].slice(0),this[r]=i),this[`_${r}_id`]++),i}_post_update_fn_data(){this.update_use_static_dispatch()}sort(){for(let e of[!1,!0]){if(e&&!this.is_property)continue;this.get_fn_data(e).sort(((e,t)=>e.type-t.type||t.priority-e.priority))}}add(e){const t=e.fn;t.name&&"anonymous"!==t.name||w(t,this._callstack_name(e.package_info.id??"<unknown>"));this.get_fn_data(e.setter,!0).splice(0,0,e),this.sort(e.setter),this._post_update_fn_data()}remove(e){const t=this.get_fn_data(e.setter,!0),r=t.indexOf(e);t.splice(r,1),this._post_update_fn_data()}clear(){this.getter_data=[],this.is_property&&(this.setter_data=[]),this._post_update_fn_data()}is_empty(){return!this.getter_data.length&&!this.setter_data?.length}}b(U),Object.freeze(U);const D=new Map,P=function(t=null){D.clear();const r=t??game?.settings?.get(e,"module-priorities");if(r)for(let e of["prioritized","deprioritized"]){const t=r[e];if(!t)continue;const i="prioritized"==e?1e4:-1e4;Object.entries(t).forEach((e=>{let[t,r]=e;r.id||(r=new v(t,S.MODULE),t=r.key),D.has(t)||D.set(t,i-r.index)}))}};class R extends FormApplication{static init(){game.settings.register(e,"notify-issues-gm",{name:"Notify GM of Issues",default:!0,type:Boolean,scope:"world",config:!0,hint:"Whether to notify GMs when an issue is detected, for example a conflict."}),game.settings.register(e,"notify-issues-player",{name:"Notify Players of Issues",default:!1,type:Boolean,scope:"world",config:!0,hint:"Whether to notify Players when an issue is detected, for example a conflict."}),game.settings.register(e,"high-performance-mode",{name:"High-Performance Mode",default:!1,type:Boolean,scope:"world",config:!0,hint:"This disables most dynamic conflict detection capabilities in exchange for performance, especially relevant on low-end systems. Note that this will significantly decrease the chance conflicts are detected. As such, it is recommended to turn this off when installing or updating packages."}),game.settings.registerMenu(e,"menu",{name:"",label:"libWrapper Settings Menu",icon:"fas fa-cog",type:R,restricted:!0}),game.settings.register(e,"module-priorities",{name:"",default:{},type:Object,scope:"world",config:!1,onChange:e=>P()}),P()}static get defaultOptions(){return{...super.defaultOptions,template:"modules/lib-wrapper/templates/settings.html",height:700,title:"libWrapper Settings Menu",width:600,classes:[e,"settings"],tabs:[{navSelector:".tabs",contentSelector:"form",initial:"name"}],submitOnClose:!1,closeOnSubmit:!1}}constructor(e={},t){super(e,t)}static showYesNoDialog(e,t){new Dialog({content:e,buttons:{yes:{icon:'<i class="fas fa-check"></i>',label:"Yes",callback:t},no:{icon:'<i class="fas fa-times"></i>',label:"No"}}}).render(!0)}getActiveWrappers(){let t=[];return y.forEach((r=>{for(let i of[!1,!0]){if(i&&!r.is_property)continue;let n=r.name;i&&(n=`${n}#set`);let a={name:n,packages:[]};r.get_fn_data(i).forEach((t=>{if(t.package_info.id==e)return;const r={name:t.package_info.settingsName,type:h[t.type],perf_mode:f[t.perf_mode]};"AUTO"==r.perf_mode?r.perf_mode=null:r.perf_mode=`, ${r.perf_mode}`,a.packages.push(r)})),r.detected_classic_wrapper&&r.detected_classic_wrapper.forEach((e=>{a.packages.push({info:new v(e),type:"MANUAL",perf_mode:null})})),a.packages.length>0&&t.push(a)}})),t.sort(((e,t)=>t.packages.length-e.packages.length)),t}getConflicts(){if(!T.collect_stats)return null;let e=[];return T.conflicts.forEach((t=>{let r=[];e.push({count:t.count,package_id:t.package_info.settingsName,other_id:t.other_info.settingsName,targets:r}),t.targets.forEach(((e,t)=>{r.push({target:t,count:e})})),r.sort(((e,t)=>e.count-t.count))})),e.sort(((e,t)=>e.count-t.count)),e}getPackages(){let t={prioritized:[],normal:[],deprioritized:[]};const r=game.settings.get(e,"module-priorities"),i=r.prioritized??{},n=r.deprioritized??{};return T.collect_stats&&(T.packages.forEach((e=>{const r=new v(e);r.key in i||r.key in n||t.normal.push(r)})),t.normal.sort(((e,t)=>e.id.localeCompare(t.id)))),Object.entries(i).forEach((e=>{let[r,i]=e;i.id||(i=new v(r,S.MODULE),r=i.key),t.prioritized.push({key:r,id:i.id,title:i.title??`${i.title} <Inactive>`,index:i.index})})),t.prioritized.sort(((e,t)=>e.index-t.index)),Object.entries(n).forEach((e=>{let[r,n]=e;r in i||(n.id||(n=new v(r,S.MODULE),r=n.key),t.deprioritized.push({key:r,id:n.id,title:n.title??`${n.title} <Inactive>`,index:n.index}))})),t.deprioritized.sort(((e,t)=>e.index-t.index)),t}getData(){return{about:{name:"libWrapper",version:t,collect_stats:T.collect_stats},wrappers:this.getActiveWrappers(),conflicts:this.getConflicts(),packages:this.getPackages()}}activateListeners(e){super.activateListeners(e);let t=this;e.find(".caret.has-nested").on("click",(function(e){const t=$(this);t.parent().find(".nested").toggleClass("active"),t.toggleClass("caret-down")})),e.find("button#reload").on("click",(function(e){t.render(!0)})),e.find(".package-priority-group").on("click",(function(e){const t=$(this).find("select");t.is(":focus")||t.focus()})),e.find("button.change-priority").on("click",(function(t){const r=$(this),i=r.data("which"),n="up"===r.data("direction"),a=e.find(`#${i}`).find("option:selected"),s=n?a.prev():a.next();s.length&&(n?s.before(a):s.after(a))})),e.find("button.change-category").on("click",(function(t){const r=$(this),i=r.data("from"),n=r.data("to"),a=e.find(`#${i}`),s=e.find(`#${n}`),o=a.find("option:selected");let c=o.next();if(0==c.length&&(c=o.prev()),s.append(o),"packages-normal"==n){const e=s.find("option");e.sort(((e,t)=>$(e).val()>$(t).val()?1:-1)),s.empty().append(e)}c.length&&a.val(c.val()),a.focus()})),e.find("#submit").on("click",(function(t){for(let t of["packages-prioritized","packages-deprioritized"]){const r=e.find(`#${t}`).find("option");let i=[];r.each(((e,t)=>{i.push($(t).val())})),$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value",i.join(",")).appendTo(e)}e.submit()})),e.find("#reset").on("click",(function(t){$("input[type=hidden]").remove(),R.showYesNoDialog("<p>Resetting the package priorities will move all packages back to 'Unprioritized'. This action cannot be undone. Are you sure you want to continue?</p>",(()=>{for(let t of["packages-prioritized","packages-deprioritized"])$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value","").appendTo(e);e.submit()}))}))}async _updateObject(t,r){const i=game.settings.get(e,"module-priorities");for(let e of["prioritized","deprioritized"]){const t=`packages-${e}-hidden`;if(!(t in r))continue;const n=r[t],a=""===n?[]:n.split(",");let s=i[e]??{},o={},c=0;a.forEach((e=>{if(!e)return;const t=s[e],r=new v(e);o[e]={id:r.id,title:r.exists?r.title:t.title,index:c++}})),i[e]=o}Object.keys(i.deprioritized).forEach((e=>{e in i.prioritized&&delete i.deprioritized[e]})),await game.settings.set(e,"module-priorities",i),this.render(!0),R.showYesNoDialog("<p>It is recommended you reload this page to apply the new package priorities. Do you wish to reload?</p>",(()=>location.reload()))}}Object.freeze(R);let x=!1,L=!0;function M(e,t,r,i){const n=new U(e,t,r,i);return y.add(n),n}function F(e){let t=e.endsWith("#set");return[t?e.slice(0,-4):e,t]}function H(e){return/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(e)}function Y(e,t){const r=F(e)[0],i=r.split("."),n=i.pop(),a=i.splice(0,1)[0];if(!H(a))throw new C(`Invalid target '${r}.'`,t);if("libWrapper"==a)throw new C("Not allowed to wrap libWrapper internals.",t);const s=function(e){try{return globalThis[e]??g(e)}catch(e){return}}(a);if(!s)throw new C(`Could not find target '${r}'.`,t);let o=s;for(let e of i){if(!H(e))throw new C(`Invalid target '${r}'.`,t);if(o=o[e],!o)throw new C(`Could not find target '${r}'.`,t)}return[o,n,r]}function G(e){const t=F(e)[0];for(let e of y)if(-1!=e.names.indexOf(t))return e;return null}function V(e,t,r){return t.get_fn_data(r).find((t=>t.package_info?.equals(e)))}function K(e){e.is_empty()&&c&&(e.unwrap(),y.delete(e))}function q(t){let r=new v;if(!t||"string"!=typeof t)throw new C("Parameter 'package_id' must be a string.",r);if(r.exists){if(t!=r.id)throw new C(`${r.logStringCapitalized} is not allowed to call libWrapper with package_id='${t}'.`,r)}else r=new v(t);if(t==e){if(!L)throw new C(`Not allowed to call libWrapper with package_id='${t}'.`,r)}else if(!r.exists)throw new C(`Package '${t}' is not a valid package.`,r);return r}let B=!1;class X{static get version(){return t}static get versions(){return[r,i,n,a,s]}static get is_fallback(){return!1}static get debug(){return l}static set debug(e){l=e}static get LibWrapperError(){return A}static get Error(){return A}static get LibWrapperInternalError(){return I}static get InternalError(){return I}static get LibWrapperPackageError(){return C}static get PackageError(){return C}static get LibWrapperModuleError(){return C}static get ModuleError(){return C}static get LibWrapperAlreadyOverriddenError(){return j}static get AlreadyOverriddenError(){return j}static get LibWrapperInvalidWrapperChainError(){return N}static get InvalidWrapperChainError(){return N}static get onUnhandledError(){return z}static version_at_least(e,t=0,s=0,o=0){return r==e?i==t?n==s?a==o:n>=s:i>t:r>e}static register(t,r,i,n="MIXED",a={}){const s=q(t);if(t!=e&&!x)throw new C("Not allowed to register wrappers before the 'libWrapperReady' hook fires",s);if(!r||"string"!=typeof r)throw new C("Parameter 'target' must be a string.",s);if(!(i&&i instanceof Function))throw new C("Parameter 'fn' must be a function.",s);if(void 0===(n=d[n.toUpperCase()])||!(n in h))throw new C(`Parameter 'type' must be one of [${p.join(", ")}].`,s);const c=a?.chain??n<d.OVERRIDE;if("boolean"!=typeof c)throw new C("Parameter 'chain' must be a boolean.",s);o&&B&&(a.perf_mode="FAST");const g=u[a?.perf_mode?.toUpperCase()??"AUTO"];if(void 0===g||!(g in f))throw new C(`Parameter 'perf_mode' must be one of [${_.join(", ")}].`,s);const w=F(r),m=w[0],b=w[1];let y=function(e,t=null){return M(...Y(e),t)}(r,s);if(b&&!y.is_property)throw new C(`Cannot register a wrapper for '${r}' by ${s.logString}' because '${m}' is not a property, and therefore has no setter.`,s);if(V(s,y,b))throw new C(`A wrapper for '${r}' has already been registered by ${s.logString}.`,s);const k=function(t,r){if(t.id===e)return Number.MAX_VALUE;const i=D.get(t.key);return void 0!==i?i:0}(s);if(s.id!=e&&T.register_package(s),n>=d.OVERRIDE){const e=y.get_fn_data(b).find((e=>e.type==d.OVERRIDE));if(e){if(k<=e.priority)throw new j(s,e.package_info,y.name);!1!==Hooks.call("libWrapper.OverrideLost",e.package_info.id,s.id,y.name)&&(T.register_conflict(s,e.package_info,y.name),E.conflict(e.package_info,s,!1,`${s.logStringCapitalized} has higher priority, and is replacing the 'OVERRIDE' registered by ${s.logString} for '${y.name}'.`))}}let $={package_info:s,target:r,setter:b,fn:i,type:n,wrapper:y,priority:k,chain:c,perf_mode:g};y.add($),(l||!o&&s.id!=e)&&(Hooks.callAll("libWrapper.Register",s.id,r,n,a),console.info(`libWrapper: Registered a wrapper for '${r}' by ${s.logString} with type ${h[n]}.`))}static unregister(t,r,i=!0){const n=q(t),a=function(e,t){const r=F(t),i=r[0],n=r[1],a=G(i);return a?V(e,a,n):null}(n,r);if(!a){if(i)throw new C(`Cannot unregister '${r}' by ${n.logString} as no such wrapper has been registered`,n);return}const s=a.wrapper;s.remove(a),K(s),(l||n.id!=e)&&(Hooks.callAll("libWrapper.Unregister",n.id,r),console.info(`libWrapper: Unregistered the wrapper for '${r}' by ${n.logString}.`))}static clear_all(t){const r=q(t);for(let e of y)this.unregister(r.id,e.name,!1),e.is_property&&this.unregister(r.id,`${e.name}#set`,!1);(l||r.id!=e)&&(Hooks.callAll("libWrapper.ClearAll",r.id),Hooks.callAll("libWrapper.ClearModule",r.id),console.info(`libWrapper: Cleared all wrapper functions by ${r.logString}.`))}static get clear_module(){return this.clear_all}}b(X),o&&(X._UT_unwrap_all=function(){for(let e of y)e.clear(),e.unwrap();y.clear()},X._UT_create_wrapper_from_object=M,X._UT_clear=function(e){const t=G(e);t&&(t.clear(),K(t),console.info(`libWrapper: Cleared all wrapper functions for '${e}'.`))},X._UT_force_fast_mode=function(e){B=e},X._UT_get_force_fast_mode=()=>B),Object.freeze(X),delete globalThis.libWrapper,Object.defineProperty(globalThis,"libWrapper",{get:()=>X,set:e=>{throw"libWrapper: Not allowed to re-assign the global instance of libWrapper"},configurable:!1}),function(){if(!o){globalThis.addEventListener("error",z),globalThis.addEventListener("unhandledrejection",z);try{const e="() => function "+Hooks._call.toString(),t=e.replace(/^( *).*catch\((.*)\)\s*{/gim,"$&\n$1  globalThis.libWrapper.onUnhandledError($2);");if(e===t)throw`Could not patch 'Hooks._call' method:\n${e}`;l&&console.log(`Patched Hooks._call: ${t}`);const r=g(t)?.();if("function"!=typeof r)throw`Evaluation of patched 'Hooks._call' method did not return a function:\nPatched Method: ${t}\nReturned: ${r}`;Hooks._call=r}catch(e){E.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Hooks._call' wrapper.\n","warn",e)}try{libWrapper.register("lib-wrapper","Application.prototype._render",(function(e,...t){return e(...t).catch((e=>{throw z(e),e}))}),"WRAPPER",{perf_mode:"FAST"})}catch(e){E.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Application.prototype._render' wrapper.\n","warn",e)}}}();{const c=m("libWrapperInit"),l={[c]:function(o,...c){x=!0,function(){if(t)return;const o=game.modules?.get(e)?.data?.version;if(!o)throw"libWrapper: Unable to find version string inside 'game.modules'";const c=o.match(/^([0-9]+)\.([0-9]+)\.([0-9]+).([0-9]+)(.*)$/i);if(!c)throw`libWrapper: Unable to parse version string '${o}'`;t=c[0],r=parseInt(c[1]),i=parseInt(c[2]),n=parseInt(c[3]),a=parseInt(c[4]),s=c[5]}(),R.init(),T.init(),E.init(),console.info(`libWrapper ${t}: Ready.`),Hooks.callAll("libWrapper.Ready",X);return o(...c)}};o?l[c]((()=>{})):X.register("lib-wrapper","Game.prototype.initialize",l[c],"WRAPPER",{perf_mode:"FAST"})}L=!1;//# sourceMappingURL=lib-wrapper.js.map
