const e="lib-wrapper";let t="",r=-1,i=-1,n=-1,s=-1,a="";const o="undefined"==typeof Game,l=!!o;let c=!1;const p=["WRAPPER","MIXED","OVERRIDE"];Object.freeze(p);const d={WRAPPER:1,MIXED:2,OVERRIDE:3};Object.freeze(d);const h={};for(let e in d)h[d[e]]=e;Object.freeze(h);const u=["STANDARD","AUTO","FAST"];Object.freeze(u);const _={STANDARD:1,AUTO:2,FAST:3};Object.freeze(_);const f={};for(let e in _)f[_[e]]=e;function g(t){if(void 0===t){const e=Error.stackTraceLimit;if(Error.stackTraceLimit=1/0,t=Error().stack,Error.stackTraceLimit=e,!t)return null}const r=t.matchAll(/(?<=\/)(modules|systems)\/(.+?)(?=\/)/gi);if(!r)return null;for(let t of r){const r=t[1],i=t[2];if("systems"!==r){if("modules"===r){if(!i||i==e||!game?.modules?.has(i))continue;return i}throw console.error("invalid type"),new(globalThis.libWrapper?.LibWrapperInternalError??Error)(`Invalid type: ${r}`)}if(i==game.data.system.id)return i}return null}Object.freeze(f);const m=eval;function w(e,t){try{e.displayName=t,Object.defineProperty(e,"name",{value:t,writable:!1,enumerable:!1,configurable:!0})}catch(e){if(o)throw e}}function b(e,t=""){return""!==t?`🎁${e}#${t}`:`🎁${e}`}function y(e){const t=Object.getOwnPropertyNames(e);t.push(...Object.getOwnPropertySymbols(e));for(const r of t){const t=Object.getOwnPropertyDescriptor(e,r);"function"==typeof t.value&&w(t.value,b(r)),"function"==typeof t.get&&w(t.get,b(r,"getter")),"function"==typeof t.set&&w(t.set,b(r,"setter"))}e.prototype&&y(e.prototype)}const O=new Set;function E(e){throw globalThis.libWrapper?new globalThis.libWrapper.LibWrapperInternalError(e):new Error(e)}const v=function(e=!1){const t=game?.user?.data;if(t)return t;const r=game.userId??game.data.userId;if(!r){if(e)return null;E("Unable to obtain the current user ID")}const i=game.data.users.find((e=>e._id==r));if(!i){if(e)return null;E("Unable to obtain the current user data object")}return i};class W{static init(){}static get ui_notifications_enabled(){try{if(function(e=!1){const t=game?.user?.isGM;if(void 0!==t)return t;const r=v(e);return r?4===r.role:null}()){if(!game?.settings?.get(e,"notify-issues-gm"))return!1}else if(!game?.settings?.get(e,"notify-issues-player"))return!1}catch(e){return console.error("libWrapper: Could not decide whether to show notifications or not. Defaulting to 'yes'.\n",e),!0}return!0}static ui(e,t="error"){if(!this.ui_notifications_enabled)return;if(this.NOTIFICATION_SET){if(this.NOTIFICATION_SET.has(e))return}else this.NOTIFICATION_SET=new Set;this.NOTIFICATION_SET.add(e);const r=i=>{let n=globalThis?.ui?.notifications;n?n[t].call(n,`libWrapper: ${e}`,{permanent:"error"==t}):i||game.ready||Hooks.once("ready",r,!0)};r(!1)}static console_ui(e,t,r="error",...i){console[r].call(console,`libWrapper: ${e}\n${t}`,...i),this.ui(`${e} (See JS console)`,r)}static conflict(e,t,r,i){e=e?e.startsWith("«")&&e.endsWith("»")?`module ${e}`:`module '${e}'`:"an unknown module",t=Array.isArray(t)?t.length>1?`[${t.join(", ")}]`:`'${t[0]}'`:`'${t}'`,this.console_ui(r?`Potential conflict detected between ${e} and ${t}.`:`Conflict detected between ${e} and ${t}.`,i,r?"warn":"error")}}y(W);class T extends Error{constructor(e,t,r,...i){super(`${e}\n${t}`,...i),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.ui_msg=e,this.console_msg=t,this.notification_fn=r??"error"}onUnhandled(){}}Object.freeze(T);class I extends T{constructor(e,...t){const r=g();super(r?`Internal error detected, possibly related to '${r}'.`:"Internal error detected.",e,"error",...t),this.module=r}}Object.freeze(I);class A extends T{constructor(e,t,...r){let i=!1;t||(t=t??g(),i=!0),super(t?i?`Error detected, possibly in '${t}'.`:`Error detected in '${t}'.`:"Error detected in unknown module.",e,"error",...r),this.module=t}}Object.freeze(A);class j extends T{constructor(e,t,r,...i){super(`Conflict detected between '${e}' and '${t}'.`,`Failed to wrap '${r}' for '${e}' with type OVERRIDE. A OVERRIDE wrapper for the same method has already been registered by '${t}'.`,"error",...i),this.module=e,this.conflicting_module=t,this.target=r}get conflicting_module_title(){return game.modules.get(this.conflicting_module)?.data?.title}onUnhandled(){super.onUnhandled(),LibWrapperStats.register_conflict(this.module,this.conflicting_module,this.target)}}Object.freeze(j);class k extends T{constructor(e,t,r,...i){super(t?`Error detected in '${t}'.`:`Error detected in wrapper '${e.name}'.`,r,"error",...i),this._wrapper=e,this.module=t}get wrapper_name(){return this._wrapper.name}}Object.freeze(k);const S=function(e){for(;!(e instanceof T);){if(void 0===e.reason)return;e=e.reason}try{e.ui_msg&&e.notification_fn&&W.ui(`${e.ui_msg} (See JS console)`,e.notification_fn),e.onUnhandled&&e.onUnhandled.apply(e)}catch(e){console.warn("libWrapper: Exception thrown while processing unhandled libWrapper Exception.",e)}};class z{static _collect_stats(){try{return function(e,t=!1){const r=game?.user?.can;if(r)return r(e);const i=v(t);if(!i)return null;if(4===i.role)return!0;if(e in i.permissions)return i.permissions[e];const n=game.data.settings.find((e=>"core.permissions"===e.key));if(n?.value){const t=JSON.parse(n.value)[e];if(t&&t.includes(i.role))return!0}return!1}("SETTINGS_MODIFY")}catch(e){if(o)throw e;return W.console_ui("A non-critical error occurred while initializing libWrapper.","Could not read user permissions during initialization.\n","warn",e),!0}}static init(){this.collect_stats=this._collect_stats(),this.collect_stats&&(this.MODULES=new Set,this.CONFLICTS=new Map)}static register_module(t){this.collect_stats&&t!=e&&this.MODULES.add(t)}static register_conflict(e,t,r){if(!this.collect_stats)return;if(Array.isArray(t)){let i=!1;return t.forEach((t=>{i|=z.register_conflict(e,t,r)})),i}if(!1===Hooks.call("libWrapper.ConflictDetected",e,t,r))return console.debug(`Conflict between '${e}' and '${t}' over '${r}' ignored, as 'libWrapper.ConflictDetected' hook returned false.`),!1;const i=`${e}/${t}`;let n=this.CONFLICTS.get(i);return n||(n={count:0,module:e,other:t,targets:new Map},this.CONFLICTS.set(i,n)),n.count++,n.targets.set(r,(n.targets.get(r)??0)+1),!0}static get conflicts(){return this.CONFLICTS}static get modules(){return this.MODULES}}class C{get name(){return this.names[0]}_callstack_name(e,t=this.name){return b(t,e)}constructor(e,t,r,i){this.fn_name=t,this.object=e;let n=Object.getOwnPropertyDescriptor(e,t);if(n){if(n.get?._lib_wrapper){let e=n.get?._lib_wrapper;if(r&&!e.names.indexOf(r)&&e.names.push(r),e&&e instanceof this.constructor)return e}if(!1===n.configurable)throw new A(`libWrapper: '${r}' cannot be wrapped, the corresponding descriptor has 'configurable=false'.`,i);n.get?(this.is_property=!0,this._wrapped_getter=n.get,this._wrapped_setter=n.set):(this.is_property=!1,this._wrapped=n.value)}else{if(n=this._get_inherited_descriptor(),!n)throw new A(`libWrapper: Can't wrap '${r}', target does not exist or could not be found.`,i);const e=n.get?._lib_wrapper;e?this.is_property=e.is_property:n.get??n.set?this.is_property=!0:this.is_property=!1}this.names=[],this.getter_data=[],this._getter_data_id=0,this.is_property&&(this.setter_data=[],this._setter_data_id=0),this.active=!1,this._outstanding_wrappers=0,this._warned_detected_classic_wrapper=!1,this._current_handler_id=0,this.is_property||(this._pending_wrapped_calls=[],this._pending_wrapped_calls_cnt=0),this.update_use_static_dispatch(),r||(r=t),-1==this.names.indexOf(r)&&this.names.push(r),this._wrap()}_get_handler(){const e=this._current_handler_id;if(e===this._cached_handler_id)return this._cached_handler;const t=this,r=this._callstack_name(e),i=this._wrapped,n={[r]:function(...r){const n=t.use_static_dispatch;return t.should_skip_wrappers(this,e,n)?t.get_wrapped(this,!1,i).apply(this,r):n?t.get_static_dispatch_chain(this).apply(this,r):t.call_wrapper(null,this,...r)},toString:function(){return t.get_wrapped(this).toString()}},s=n[r];return s.toString=n.toString,this._cached_handler=s,this._cached_handler_id=e,s}get_static_dispatch_chain(e){const t=this._getter_data_id;let r=null;if(t===this._cached_static_dispatch_chain_id&&e===this._cached_static_dispatch_chain_obj)r=this._cached_static_dispatch_chain;else{const i=()=>{r=this.call_wrapped.bind(this,null,e)},n=this.get_fn_data(!1);for(let t=n.length-1;t>=0;t--){const s=n[t],a=s.fn;s.chain?(r||i(),r=a.bind(e,r)):r=a.bind(e)}r||i(),this._cached_static_dispatch_chain_obj=e,this._cached_static_dispatch_chain_id=t,this._cached_static_dispatch_chain=r}return r}should_skip_wrappers(e,t,r){if(t==this._current_handler_id)return!1;if(t>this._current_handler_id)throw new I(`Unreachable: handler_id=${t} > this._current_handler_id=${this._current_handler_id}`);if(!this.is_property){if(this._pending_wrapped_calls_cnt<=0)return!1;if(!r){if(this._pending_wrapped_calls.indexOf(e)<0)return!1}}return!0}skip_existing_handlers(){this._current_handler_id++}_calc_use_static_dispatch(){const t=this.get_fn_data(!1);let r;for(const e of t)if(e.perf_mode)if(void 0===r)r=e.perf_mode;else if(r!==e.perf_mode){r=_.AUTO;break}return r===_.FAST||r!==_.SAFE&&!!game?.settings?.get(e,"high-performance-mode")}update_use_static_dispatch(){this.use_static_dispatch=this._calc_use_static_dispatch()}_wrap(){if(this.active)return;const e=this._callstack_name("getter"),t=this._callstack_name("setter");let r;if(this.is_property){const i=this;r={[e]:function(...e){return i.call_wrapper(null,this,...e)},[t]:function(...e){return i.call_wrapper({setter:!0},this,...e)}}}else{const i=this;r={[e]:()=>i._get_handler(),[t]:function(e){return i.set_nonproperty(e,this)}}}const i=r[e],n=r[t];i._lib_wrapper=this,Object.defineProperty(this.object,this.fn_name,{get:i,set:n,configurable:l}),this.active=!0,console.debug(`libWrapper: Wrapped '${this.name}'.`)}unwrap(){if(this.active){if(!l)throw new I("libWrapper: Cannot unwrap when PROPERTIES_CONFIGURABLE==false");delete this.object[this.fn_name],this.is_property?Object.defineProperty(this.object,this.fn_name,{get:this._wrapped_getter,set:this._wrapped_setter,configurable:!0}):this.object[this.fn_name]=this._wrapped,this.active=!1,console.debug(`libWrapper: Unwrapped '${this.name}'.`)}}_get_inherited_descriptor(){let e=Object.getPrototypeOf(this.object),t=null;for(;e;){if(t=Object.getOwnPropertyDescriptor(e,this.fn_name),t)return t;e=Object.getPrototypeOf(e)}return null}get_wrapped(e,t=!1,r=this._wrapped){let i;if(i=this.is_property?t?this._wrapped_setter:this._wrapped_getter:r,void 0===i){const r=this._get_inherited_descriptor();if(r)if(this.is_property){if(r.get??!r.set)throw new I("This wrapper is set up to wrap a property, but the inherited descriptor is a method.");i=t?r.set:r.get}else i=r.value??r.get.apply(e)}return void 0===i&&console.warn(`libWrapper: There is no wrapped method for '${this.name}', returning 'undefined'.`),i}call_wrapped(e,t,...r){e&&this._call_wrapper_update_state(e);const i=e?.setter??!1,n=!!e;let s,a;this.is_property||(this._pending_wrapped_calls_cnt++,n&&(s=t,this._pending_wrapped_calls.push(s)));try{a=this.get_wrapped(this.object,i)?.apply(t,r)}catch(e){throw this.is_property||this._cleanup_call_wrapped(s,n),e}return this.is_property||("function"==typeof a?.then?a=a.then((e=>(this._cleanup_call_wrapped(s,n),e)),(e=>{throw this._cleanup_call_wrapped(s,n),e})):this._cleanup_call_wrapped(s,n)),a}_cleanup_call_wrapped(e,t){if(!this._pending_wrapped_calls_cnt)throw new I(`this._pending_wrapped_calls_cnt=${this._pending_wrapped_calls_cnt} should be unreachable at this point.`);if(this._pending_wrapped_calls_cnt--,t){const t=this._pending_wrapped_calls.indexOf(e);if(t<0)throw new I("Could not find 'pend' inside 'this._pending_wrapped_calls'.");this._pending_wrapped_calls.splice(t,1)}}call_wrapper(e,t,...r){e&&this._call_wrapper_update_state(e);const i=e?.index??0,n=e?.setter??!1,s=e?.fn_data??this.get_fn_data(n),a=s[i];if(!a){if(s.length>0)throw new I(`Must not have 'data===${a}' when 'fn_data.length==${s.length}'.`);return this.call_wrapped(null,t,...r)}const o=a.fn;if(!a.chain)return o.apply(t,r);const l=i+1,c=l>=s.length,p={index:l,called:!1,valid:!0,setter:n,prev_data:a,fn_data:s},d=c?this.call_wrapped.bind(this,p,t):this.call_wrapper.bind(this,p,t);let h;this._outstanding_wrappers++;try{h=o.call(t,d,...r)}catch(e){return this._cleanup_call_wrapper_thrown(p,e)}return h="function"==typeof h?.then?h.then((e=>this._cleanup_call_wrapper(e,p,a,s,d,t,r)),(e=>this._cleanup_call_wrapper_thrown(p,e))):this._cleanup_call_wrapper(h,p,a,s,d,t,r),h}_call_wrapper_update_state(e){if("valid"in e&&!e.valid)throw new k(this,e.prev_data?.module,`This wrapper function for '${this.name}' is no longer valid, and must not be called.`);e.called=!0}_invalidate_state(e){if(e.valid=!1,this._outstanding_wrappers--,this._outstanding_wrappers<0)throw new I(`Outstanding wrappers = ${this._outstanding_wrappers}, should never fall below 0.`)}_cleanup_call_wrapper_thrown(e,t){throw this._invalidate_state(e),t}_cleanup_call_wrapper(e,t,r,i,n,s,a){try{if(!t.called){let o=!r.warned_conflict||z.collect_stats,l=null,c=!1;o&&(l=i.slice(t.index).filter((e=>e.module!=r.module)).map((e=>e.module)),c=0==l.length,z.register_conflict(r.module,l,this.name)),r.type==d.WRAPPER?(W.console_ui(`Error detected in module '${r.module}'.`,`The wrapper for '${r.target}' registered by module '${r.module}' with type WRAPPER did not chain the call to the next wrapper, which breaks a libWrapper API requirement. This wrapper will be unregistered.`,"error"),globalThis.libWrapper.unregister(r.module,r.target),c||(e=n.apply(s,a))):r.warned_conflict||c||(W.conflict(r.module,l,!0,`Module '${r.module}' did not chain the wrapper for '${r.target}'.`),r.warned_conflict=!0)}}finally{this._invalidate_state(t)}return e}set_nonproperty(e,t=null){if(this.is_property)throw new I("Must not call 'set_nonproperty' for a property wrapper.");t!==this.object?Object.defineProperty(t,this.fn_name,{value:e,configurable:!0,enumerable:!0,writable:!0}):(this._wrapped=e,this.skip_existing_handlers(),this.warn_classic_wrapper())}get_affected_modules(){return this.getter_data.map((e=>e.module))}warn_classic_wrapper(){const e=g()??"«unknown»",t=this.get_affected_modules();if(t.length>0){z.register_conflict(e,t,this.name)&&(W.conflict(e,t,!0,`Detected non-libWrapper wrapping of '${this.name}' by '${e}'. This will potentially lead to conflicts.`),c&&console.trace&&console.trace())}this.detected_classic_wrapper||(this.detected_classic_wrapper=[]),this.detected_classic_wrapper.push(e)}get_fn_data(e,t=!1){if(e&&!this.is_property)throw new I(`libWrapper: '${this.name}' does not wrap a property, thus setter=true is illegal.`);const r=e?"setter_data":"getter_data";let i=this[r];return t&&(this._outstanding_wrappers>0&&(i=this[r].slice(0),this[r]=i),this[`_${r}_id`]++),i}_post_update_fn_data(){this.update_use_static_dispatch()}sort(){for(let e of[!1,!0]){if(e&&!this.is_property)continue;this.get_fn_data(e).sort(((e,t)=>e.type-t.type||t.priority-e.priority))}}add(e){const t=e.fn;t.name&&"anonymous"!==t.name||w(t,this._callstack_name(e.module??"<unknown>"));this.get_fn_data(e.setter,!0).splice(0,0,e),this.sort(e.setter),this._post_update_fn_data()}remove(e){const t=this.get_fn_data(e.setter,!0),r=t.indexOf(e);t.splice(r,1),this._post_update_fn_data()}clear(){this.getter_data=[],this.is_property&&(this.setter_data=[]),this._post_update_fn_data()}is_empty(){return!this.getter_data.length&&!this.setter_data?.length}}y(C),Object.freeze(C);const R=new Map,P=function(t=null){const r=g();if(r)throw new A(`Module '${r}' is not allowed to call libWrapper.load_priorities()`,r);R.clear();const i=t??game?.settings?.get(e,"module-priorities");if(i)for(let e of["prioritized","deprioritized"]){const t=i[e];if(!t)continue;const r="prioritized"==e?1e4:-1e4;Object.entries(t).forEach((e=>{const[t,i]=e;R.has(t)||R.set(t,r-i.index)}))}};class x extends FormApplication{static init(){game.settings.register(e,"notify-issues-gm",{name:"Notify GM of Issues",default:!0,type:Boolean,scope:"world",config:!0,hint:"Whether to notify GMs when an issue is detected, for example a conflict."}),game.settings.register(e,"notify-issues-player",{name:"Notify Players of Issues",default:!1,type:Boolean,scope:"world",config:!0,hint:"Whether to notify Players when an issue is detected, for example a conflict."}),game.settings.register(e,"high-performance-mode",{name:"High-Performance Mode",default:!1,type:Boolean,scope:"world",config:!0,hint:"This disables most dynamic conflict detection capabilities in exchange for performance, especially relevant on low-end systems. Note that this will significantly decrease the chance conflicts are detected. As such, it is recommended to turn this off when installing or updating modules."}),game.settings.registerMenu(e,"menu",{name:"",label:"libWrapper Settings Menu",icon:"fas fa-cog",type:x,restricted:!0}),game.settings.register(e,"module-priorities",{name:"",default:{},type:Object,scope:"world",config:!1,onChange:e=>P()}),P()}static get defaultOptions(){return{...super.defaultOptions,template:"modules/lib-wrapper/templates/settings.html",height:700,title:"libWrapper Settings Menu",width:600,classes:[e,"settings"],tabs:[{navSelector:".tabs",contentSelector:"form",initial:"name"}],submitOnClose:!1,closeOnSubmit:!1}}constructor(e={},t){super(e,t)}static showYesNoDialog(e,t){new Dialog({content:e,buttons:{yes:{icon:'<i class="fas fa-check"></i>',label:"Yes",callback:t},no:{icon:'<i class="fas fa-times"></i>',label:"No"}}}).render(!0)}_get_module_data(e){return e===game.data.system.id?(console.log(game.data.system),game.data.system.data):game.modules.get(e)?.data}getActiveWrappers(){let t=[];return O.forEach((r=>{for(let i of[!1,!0]){if(i&&!r.is_property)continue;let n=r.name;i&&(n=`${n}#set`);let s={name:n,modules:[]};r.get_fn_data(i).forEach((t=>{if(t.module==e)return;const r={name:t.module,type:h[t.type],perf_mode:f[t.perf_mode]};"AUTO"==r.perf_mode?r.perf_mode=null:r.perf_mode=`, ${r.perf_mode}`,s.modules.push(r)})),r.detected_classic_wrapper&&r.detected_classic_wrapper.forEach((e=>{s.modules.push({name:e,type:"MANUAL",perf_mode:null})})),s.modules.length>0&&t.push(s)}})),t.sort(((e,t)=>t.modules.length-e.modules.length)),t}getConflicts(){if(!z.collect_stats)return null;let e=[];return z.conflicts.forEach((t=>{let r=[];e.push({count:t.count,module:t.module,other:t.other,targets:r}),t.targets.forEach(((e,t)=>{r.push({target:t,count:e})})),r.sort(((e,t)=>e.count-t.count))})),e.sort(((e,t)=>e.count-t.count)),e}getModules(){let t={prioritized:[],normal:[],deprioritized:[]};const r=game.settings.get(e,"module-priorities"),i=r.prioritized??{},n=r.deprioritized??{};return z.collect_stats&&(z.modules.forEach((e=>{const r=this._get_module_data(e);e in i||e in n||t.normal.push({id:e,title:r.title})})),t.normal.sort(((e,t)=>e.id-t.id))),Object.entries(i).forEach((e=>{const[r,i]=e,n=this._get_module_data(r);t.prioritized.push({id:r,title:n?.title??`${i.title} <Inactive>`,index:i.index})})),t.prioritized.sort(((e,t)=>e.index-t.index)),Object.entries(n).forEach((e=>{const[r,n]=e;if(r in i)return;const s=this._get_module_data(r);t.deprioritized.push({id:r,title:s?.title??`${n.title} <Inactive>`,index:n.index})})),t.deprioritized.sort(((e,t)=>e.index-t.index)),t}getData(){return{about:{name:"libWrapper",version:t,collect_stats:z.collect_stats},wrappers:this.getActiveWrappers(),conflicts:this.getConflicts(),modules:this.getModules()}}activateListeners(e){super.activateListeners(e);let t=this;e.find(".caret.has-nested").on("click",(function(e){const t=$(this);t.parent().find(".nested").toggleClass("active"),t.toggleClass("caret-down")})),e.find("button#reload").on("click",(function(e){t.render(!0)})),e.find(".module-priority-group").on("click",(function(e){const t=$(this).find("select");t.is(":focus")||t.focus()})),e.find("button.change-priority").on("click",(function(t){const r=$(this),i=r.data("which"),n="up"===r.data("direction"),s=e.find(`#${i}`).find("option:selected"),a=n?s.prev():s.next();a.length&&(n?a.before(s):a.after(s))})),e.find("button.change-category").on("click",(function(t){const r=$(this),i=r.data("from"),n=r.data("to"),s=e.find(`#${i}`),a=e.find(`#${n}`),o=s.find("option:selected");let l=o.next();if(0==l.length&&(l=o.prev()),a.append(o),"modules-normal"==n){const e=a.find("option");e.sort(((e,t)=>$(e).val()>$(t).val()?1:-1)),a.empty().append(e)}l.length&&s.val(l.val()),s.focus()})),e.find("#submit").on("click",(function(t){for(let t of["modules-prioritized","modules-deprioritized"]){const r=e.find(`#${t}`).find("option");let i=[];r.each(((e,t)=>{i.push($(t).val())})),$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value",i.join(",")).appendTo(e)}e.submit()})),e.find("#reset").on("click",(function(t){$("input[type=hidden]").remove(),x.showYesNoDialog("<p>Resetting the module priorities will move all modules back to 'Unprioritized'. This action cannot be undone. Are you sure you want to continue?</p>",(()=>{for(let t of["modules-prioritized","modules-deprioritized"])$("<input>").attr("type","hidden").attr("name",`${t}-hidden`).attr("value","").appendTo(e);e.submit()}))}))}async _updateObject(t,r){const i=game.settings.get(e,"module-priorities");for(let e of["prioritized","deprioritized"]){const t=`modules-${e}-hidden`;if(!(t in r))continue;const n=r[t],s=""===n?[]:n.split(",");let a=i[e]??{},o={},l=0;s.forEach((e=>{if(!e)return;const t=a[a],r=this._get_module_data(e);o[e]={title:r?.title??t?.title??"<Unknown>",index:l++}})),i[e]=o}Object.keys(i.deprioritized).forEach((e=>{e in i.prioritized&&delete i.deprioritized[e]})),await game.settings.set(e,"module-priorities",i),this.render(!0),x.showYesNoDialog("<p>It is recommended you reload this page to apply the new module priorities. Do you wish to reload?</p>",(()=>location.reload()))}}Object.freeze(x);let D=!1,M=!0;function U(e,t,r,i){const n=new C(e,t,r,i);return O.add(n),n}function N(e){let t=e.endsWith("#set");return[t?e.slice(0,-4):e,t]}function L(e){return/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(e)}function F(e,t){const r=N(e)[0],i=r.split("."),n=i.pop(),s=i.splice(0,1)[0];if(!L(s))throw new A(`Invalid target '${r}.'`,t);if("libWrapper"==s)throw new A("Not allowed to wrap libWrapper internals.",t);const a=function(e){try{return globalThis[e]??m(e)}catch(e){return}}(s);if(!a)throw new A(`Could not find target '${r}'.`,t);let o=a;for(let e of i){if(!L(e))throw new A(`Invalid target '${r}'.`,t);if(o=o[e],!o)throw new A(`Could not find target '${r}'.`,t)}return[o,n,r]}function H(e){const t=N(e)[0];for(let e of O)if(-1!=e.names.indexOf(t))return e;return null}function V(e,t,r){return t.get_fn_data(r).find((t=>t.module==e))}function G(e){e.is_empty()&&l&&(e.unwrap(),O.delete(e))}function Y(t){const r=g();if(!t||"string"!=typeof t)throw new A("Parameter 'module' must be a string.",r);if(t==e){if(!M)throw new A(`Not allowed to call libWrapper with module='${t}'.`,r)}else if(t!=game.data.system.id&&!game.modules.get(t)?.active)throw new A(`Module '${t}' is not a valid module.`,r);if(r&&t!=r)throw new A(`Module '${r}' is not allowed to call libWrapper with module='${t}'.`,r)}let B=!1;class X{static get version(){return t}static get versions(){return[r,i,n,s,a]}static get is_fallback(){return!1}static get debug(){return c}static set debug(e){c=e}static get LibWrapperError(){return T}static get Error(){return T}static get LibWrapperInternalError(){return I}static get InternalError(){return I}static get LibWrapperModuleError(){return A}static get ModuleError(){return A}static get LibWrapperAlreadyOverriddenError(){return j}static get AlreadyOverriddenError(){return j}static get LibWrapperInvalidWrapperChainError(){return k}static get InvalidWrapperChainError(){return k}static version_at_least(e,t=0,a=0,o=0){return r==e?i==t?n==a?s==o:n>=a:i>t:r>e}static register(t,r,i,n="MIXED",s={}){if(Y(t),t!=e&&!D)throw new A("Not allowed to register wrappers before the 'libWrapperReady' hook fires",t);if(!r||"string"!=typeof r)throw new A("Parameter 'target' must be a string.",t);if(!(i&&i instanceof Function))throw new A("Parameter 'fn' must be a function.",t);if(void 0===(n=d[n.toUpperCase()])||!(n in h))throw new A(`Parameter 'type' must be one of [${p.join(", ")}].`,t);const a=s?.chain??n<d.OVERRIDE;if("boolean"!=typeof a)throw new A("Parameter 'chain' must be a boolean.",t);o&&B&&(s.perf_mode="FAST");const l=_[s?.perf_mode?.toUpperCase()??"AUTO"];if(void 0===l||!(l in f))throw new A(`Parameter 'perf_mode' must be one of [${u.join(", ")}].`,t);const g=N(r),m=g[0],w=g[1];let b=function(e,t=null){return U(...F(e),t)}(r,t);if(w&&!b.is_property)throw new A(`Cannot register a wrapper for '${r}' by '${t}' because '${m}' is not a property, and therefore has no setter.`,t);if(V(t,b,w))throw new A(`Module '${t}' has already registered a wrapper for '${r}'.`,t);const y=function(t,r){if(t===e)return Number.MAX_VALUE;const i=R.get(t);return void 0!==i?i:0}(t);if(t!=e&&z.register_module(t),n>=d.OVERRIDE){const e=b.get_fn_data(w).find((e=>e.type==d.OVERRIDE));if(e){if(y<=e.priority)throw new j(t,e.module,b.name);!1!==Hooks.call("libWrapper.OverrideLost",e.module,t,b.name)&&(z.register_conflict(t,e.module,b.name),W.conflict(e.module,t,!1,`Module '${t}' has higher priority, and is replacing the OVERRIDE registered by '${e.module}' for '${b.name}'.`))}}let $={module:t,target:r,setter:w,fn:i,type:n,wrapper:b,priority:y,chain:a,perf_mode:l};b.add($),(c||!o&&t!=e)&&(Hooks.callAll("libWrapper.Register",t,r,n,s),console.info(`libWrapper: Registered a wrapper for '${r}' by '${t}' with type ${h[n]}.`))}static unregister(t,r,i=!0){Y(t);const n=function(e,t){const r=N(t),i=r[0],n=r[1],s=H(i);return s?V(e,s,n):null}(t,r);if(!n){if(i)throw new A(`Cannot unregister '${r}' by '${t}' as no such wrapper has been registered`,t);return}const s=n.wrapper;s.remove(n),G(s),(c||t!=e)&&(Hooks.callAll("libWrapper.Unregister",t,r),console.info(`libWrapper: Unregistered the wrapper for '${r}' by '${t}'.`))}static clear_module(t){Y(t);for(let e of O)this.unregister(t,e.name,!1),e.is_property&&this.unregister(t,`${e.name}#set`,!1);(c||t!=e)&&(Hooks.callAll("libWrapper.ClearModule",t),console.info(`libWrapper: Cleared all wrapper functions by module '${t}'.`))}}y(X),o&&(X._UT_unwrap_all=function(){for(let e of O)e.clear(),e.unwrap();O.clear()},X._UT_create_wrapper_from_object=U,X._UT_clear=function(e){const t=H(e);t&&(t.clear(),G(t),console.info(`libWrapper: Cleared all wrapper functions for '${e}'.`))},X._UT_force_fast_mode=function(e){B=e},X._UT_get_force_fast_mode=()=>B),Object.freeze(X),delete globalThis.libWrapper,Object.defineProperty(globalThis,"libWrapper",{get:()=>X,set:e=>{throw"libWrapper: Not allowed to re-assign the global instance of libWrapper"},configurable:!1});{const l=b("libWrapperInit"),c={[l]:function(o,...l){D=!0,function(){if(t)return;const o=game.modules?.get(e)?.data?.version;if(!o)throw"libWrapper: Unable to find version string inside 'game.modules'";const l=o.match(/^([0-9]+)\.([0-9]+)\.([0-9]+).([0-9]+)(.*)$/i);if(!l)throw`libWrapper: Unable to parse version string '${o}'`;t=l[0],r=parseInt(l[1]),i=parseInt(l[2]),n=parseInt(l[3]),s=parseInt(l[4]),a=l[5]}(),x.init(),z.init(),W.init();const c=game.data.system.id;game.modules.get(c)?.active&&W.console_ui(`Module '${c}' is active and has same ID as the current system '${c}'. This could cause issues, and is not recommended.`,"","warn"),console.info(`libWrapper ${t}: Ready.`),Hooks.callAll("libWrapperReady",X),Hooks.callAll("libWrapper.Ready",X);return o(...l)}};o?c[l]((()=>{})):X.register("lib-wrapper","Game.prototype.initialize",c[l],"WRAPPER",{perf_mode:"FAST"})}!function(){if(!o){globalThis.addEventListener("error",S),globalThis.addEventListener("unhandledrejection",S);try{libWrapper.register("lib-wrapper","Hooks._call",(function(e,...t){const r=t[1],i=`Hooks._call#hook=${t[0]}`,n={[i]:function(...e){try{return r.apply(this,e)}catch(e){throw S(e),e}}};return t[1]=n[i],this._once.includes(r)&&this.off(t[0],r),e(...t)}),"WRAPPER",{perf_mode:"FAST"})}catch(e){W.console_ui("A non-critical error occurred while initializing libWrapper.","Could not setup 'Hooks._call' wrapper.\n","warn",e)}}}(),M=!1;//# sourceMappingURL=lib-wrapper.js.map
