"use strict";export let libWrapper;Hooks.once("init",(()=>{libWrapper=!globalThis.libWrapper||(globalThis.libWrapper.is_fallback??1)?class{static get is_fallback(){return!0}static register(module,target,fn,type="MIXED",{chain}={}){const is_setter=target.endsWith("#set"),split=(target=is_setter?target.slice(0,-4):target).split("."),fn_name=split.pop(),root_nm=split.splice(0,1)[0],_eval=eval,obj=split.reduce(((x,y)=>x[y]),globalThis[root_nm]??_eval(root_nm));let iObj=obj,descriptor=null;for(;iObj&&(descriptor=Object.getOwnPropertyDescriptor(iObj,fn_name),!descriptor);)iObj=Object.getPrototypeOf(iObj);if(!descriptor||!1===descriptor?.configurable)throw`libWrapper Shim: '${target}' does not exist, could not be found, or has a non-configurable descriptor.`;let original=null;const wrapper=chain??"OVERRIDE"!=type?function(){return fn.call(this,original.bind(this),...arguments)}:function(){return fn.apply(this,arguments)};if(is_setter){if(!descriptor.set)throw`libWrapper Shim: '${target}' does not have a setter`;original=descriptor.set,descriptor.set=wrapper}else descriptor.value?(original=descriptor.value,descriptor.value=wrapper):(original=descriptor.get,descriptor.get=wrapper);descriptor.configurable=!0,Object.defineProperty(obj,fn_name,descriptor)}}:globalThis.libWrapper}));