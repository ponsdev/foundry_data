{"_id":"0CvJdICTQeqhQXXC","name":"Hidden / Lesser Cover","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/mystery-man.svg","scope":"global","command":"// A macro for Pathfinder 2e to toggle lesser cover. Written by @mistamichal5724   \n// Select the token / Selecione o token\n\nif (token.data.effects.includes(\"systems/pf2e/icons/conditions-2/hidden.png\")) { \n  actor.removeCustomModifier('ac', 'Lesser cover') \n  token.toggleEffect(\"systems/pf2e/icons/conditions-2/hidden.png\") \n} else { \n  actor.addCustomModifier('ac', 'Lesser cover', 1, 'circumstance'); \n  token.toggleEffect(\"systems/pf2e/icons/conditions-2/hidden.png\") \n};","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{}}
{"_id":"346oM8mdRePVsd9r","name":"Modelo Area - FEET","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/circle.svg","scope":"global","command":"let applyChanges = false\nnew Dialog({\n  title: `Template creator`,\n  content: `\n    <style>\n      #pf2-template-creator header {\n        border-radius: 0;\n        background: linear-gradient(90deg, var(--secondary) 0%, #202b93 50%, var(--secondary) 100%);\n        border: none;\n        box-shadow: inset 0 0 0 1px #9f725b,inset 0 0 0 2px var(--tertiary),inset 0 0 0 3px #956d58;\n        margin-bottom: 2px;\n        font-size: .75rem;\n      }\n      #pf2-template-creator .window-content {\n        background-image: url(systems/pf2e/assets/sheet/red_bg.jpg);\n        color: #ffefbd;\n        padding: 9px;\n        border-width: 9px;\n        border-image: url(systems/pf2e/assets/sheet/corner-box.png) 9 repeat;\n      }\n      #pf2-template-creator form {\n        margin-bottom: 20px;\n      }\n      #pf2-template-creator .form-fields.buttons {\n        justify-content: flex-start !important;\n      }\n      #pf2-template-creator .button {\n        flex: 1 !important;\n        border-width: 9px;\n        border-image: url(systems/pf2e/assets/sheet/corner-box.png) 9 repeat;\n        font-size: 12px;\n        padding: 0;\n        background: #171f69;\n        color: #ffefbd;\n        cursor: pointer;\n      }\n      #pf2-template-creator .button:hover {\n        box-shadow: 0 0 8px white;\n      }\n      #pf2-template-creator .radios input[type=\"radio\"] {\n        opacity: 0;\n        position: fixed;\n        width: 0;\n      }\n      #pf2-template-creator .radios label {\n        cursor: pointer;\n        display: flex;\n        flex: 1 !important;\n        margin: -2px 0;\n        background: rgba(0, 0, 0, 0.1);\n        border: 2px groove #f0f0e0;\n        width: 100%;\n        border-radius: 3px;\n        font-size: 13px;\n        font-family: \"Signika\", sans-serif;\n        justify-content: center;\n        align-items: center;\n        background: #171f69;\n        color: #ffefbd;\n        border-width: 9px;\n        border-image: url(systems/pf2e/assets/sheet/corner-box.png) 9 repeat;\n      }\n      #pf2-template-creator .radios label i {\n        margin-right: 5px;\n        color: #ffefbd;\n        background: #171f69;\n      }\n      #pf2-template-creator .radios label:hover {\n        box-shadow: 0 0 8px white;\n      }\n      #pf2-template-creator .radios input[type=\"radio\"]:checked + label {\n        background: rgba(0, 0, 0, 0.2);\n      }\n      #pf2-template-creator .dialog-button {\n        height: 50px;\n        background: #171f69;\n        border-image: url(systems/pf2e/assets/sheet/corner-box.png) 9 repeat;\n        color: #ffefbd;\n        border-width: 9px;\n        display: inline-flex;\n        justify-content: space-evenly;\n        align-items: center;\n        cursor: pointer;\n      }\n      #pf2-template-creator .notes {\n        color: #ffefbd !important;\n        flex: 0 0 100% !important;\n        font-size: 12px !important;\n        line-height: 16px !important;\n        margin: 10px 0 5px 0 !important;\n      }\n      #pf2-template-creator .notes.title {\n        border-bottom: 1px solid #f7d488;\n        font-size: 14px !important;\n        font-weight: bold;\n        margin: 20px 0 10px 0 !important;\n      }\n    </style>\n    <form>\n      <div class=\"form-group\">\n        <p class=\"notes title\">Zone type:</p>\n        <div class=\"form-fields buttons radios\">\n          <input type=\"radio\" name=\"shape\" id=\"emanation\" value=\"emanation\" checked>\n          <label for=\"emanation\" onclick=\"toggleEmanationMessage(true)\"><i class=\"fas fa-square\"></i> Emanation</label>\n          <input type=\"radio\" name=\"shape\" id=\"burst\" value=\"burst\">\n          <label for=\"burst\" onclick=\"toggleEmanationMessage(false)\"><i class=\"fas fa-dot-circle\"></i> Burst</label>\n          <input type=\"radio\" name=\"shape\" id=\"cone\" value=\"cone\">\n          <label for=\"cone\" onclick=\"toggleEmanationMessage(false)\"><i class=\"fas fa-wifi\"></i> Cone</label>\n          <input type=\"radio\" name=\"shape\" id=\"line\" value=\"line\">\n          <label for=\"line\" onclick=\"toggleEmanationMessage(false)\"><i class=\"fas fa-ruler-horizontal\"></i> Line</label>\n        </div>\n      </div>\n\n      <div class=\"notes\" id=\"emanation-message\">\n        ${token ? `\n          ➡️ The Emanation template will automatically be placed on the selected token: ${token.data.name}.<br>\n          ${game[\"token-mold\"] ? `➡️ The template will move with the selected token.` : `⚠️ For the template to move with the selected token, please install and activate the module \"TokenMold\".`}\n        ` : `\n          ➡️ To automatically place the Emanation template on a token, please run this macro with a token selected.\n        ` }\n      </div>\n\n      <div class=\"form-group\">\n        <p class=\"notes title\">Predefined values:</p>\n        <div class=\"form-fields buttons\">\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(5)\">5 ft</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(10)\">10 ft</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(15)\">15 ft</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(20)\">20 ft</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(30)\">30 ft</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(60)\">60 ft</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(120)\">120 ft</button>\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n      <p class=\"notes title\">Template radius in feet:</p>\n      <div class=\"form-fields\">\n        <input type=\"range\" id=\"radius\" name=\"radius\" value=\"5\" min=\"5\" max=\"120\" step=\"5\" oninput=\"updateRangeValue(this.value);\">\n        <span id=\"range-value\" class=\"range-value\">5</span>\n      </div>\n      </div>\n    </form>\n    <script>\n      function toggleEmanationMessage (isVisible) {\n        document.getElementById(\"emanation-message\").style.display = isVisible ? \"block\" : \"none\"\n      }\n      function updateRadiusValue(val) {\n        document.getElementById(\"radius\").value = val\n        updateRangeValue(val)\n      }\n      function updateRangeValue(val) {\n        document.getElementById(\"range-value\").innerHTML = val\n      }\n    </script>\n  `,\n  buttons: {\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel`\n    },\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply`,\n      callback: () => applyChanges = true\n    }\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n\n      // Template settings\n      const templateData = {\n        user: game.user._id,\n        distance: parseFloat(html.find('[name=\"radius\"]')[0].value),\n        direction: 0,\n        x: 0,\n        y: 0,\n        fillColor: game.user.color\n      }\n\n      let templateShape = html.find('[name=\"shape\"]')\n      for (var i = 0, length = templateShape.length; i < length; i++) {\n        if (templateShape[i].checked) {\n          templateShape = templateShape[i].value\n          break\n        }\n      }\n\n      switch (templateShape) {\n        case \"cone\":\n          templateData.t = \"cone\"\n          templateData.angle = 90\n          break\n        case \"emanation\":\n          templateData.t = \"circle\"\n          break\n        case \"line\":\n          templateData.t = \"ray\"\n          templateData.width = 5\n          break\n        case \"burst\":\n          templateData.t = \"circle\"\n          break\n        default:\n          break\n      }\n\n      const measuredTemplate = new MeasuredTemplate(templateData)\n\n      // If emanation shape then place template on token if token is selected\n      if (token && templateShape === \"emanation\") {\n        const shapeCenter = canvas.grid.getCenter(token.x, token.y)\n        measuredTemplate.data.x = shapeCenter[0]\n        measuredTemplate.data.y = shapeCenter[1]\n\n        const template = canvas.scene.createEmbeddedEntity(\"MeasuredTemplate\", measuredTemplate.data).then(template => {\n          // If tokenmold is installed and activated, stick the template to the token\n          if (game[\"token-mold\"]) {\n            let templateIds = duplicate(getProperty(token, \"data.flags.token-mold.sticky-templates.templateIds\") || [])\n            if (!templateIds.includes(template._id)) templateIds.push(template._id)\n            token.update({ \"flags.token-mold.sticky-templates.templateIds\": templateIds })\n          }\n        })\n      } else {\n        // Else prepare layer for preview\n        const highlighterName = 'Preview.' + Math.random().toString(36).substr(2, 9)\n        const highlighter = canvas.grid.addHighlightLayer(highlighterName)\n        const initialLayer = canvas.activeLayer\n        measuredTemplate.draw()\n        measuredTemplate.layer.activate()\n        measuredTemplate.layer.preview.addChild(measuredTemplate)\n\n        // Calculate the shape position\n        function getTemplatePosition(event) {\n          const center = event.data.getLocalPosition(measuredTemplate.layer)\n\n          if (templateShape === \"emanation\" || templateShape === \"line\") {\n            const shapeCenter = canvas.grid.getCenter(center.x, center.y)\n            return { x: shapeCenter[0], y: shapeCenter[1] }\n          } else if (templateShape === \"burst\") {\n            return canvas.grid.getSnappedPosition(center.x, center.y, 1)\n          } else if (templateShape === \"cone\") {\n            let shift = 0\n            const shapePosition = canvas.grid.getSnappedPosition(center.x, center.y, 2)\n            const centerPosition = canvas.grid.getCenter(shapePosition.x, shapePosition.y)\n            if (shapePosition.x === centerPosition[0] && shapePosition.y === centerPosition[1]) {\n              shapePosition.x += canvas.dimensions.size / 2\n            }\n            return shapePosition\n          } else {\n            return canvas.grid.getSnappedPosition(center.x, center.y, 2)\n          }\n        }\n\n        /*\n        ----------- THX TO PF2 SYSTEM CREATOR FOR THIS CODE. --------------\n        */\n\n        // Calculate the highlight\n        function highlightGrid() {\n          const grid = canvas.grid,\n            d = canvas.dimensions,\n            bc = \"0x000000\",\n            fc = measuredTemplate.data.fillColor.replace('#', '0x')\n\n          // Clear existing highlight\n          canvas.grid.clearHighlightLayer(highlighterName)\n          if ([\"circle\", \"cone\"].includes(measuredTemplate.data.t)) {\n            // Get number of rows and columns\n            let nr = Math.ceil(((measuredTemplate.data.distance * 1.5) / d.distance) / (d.size / grid.h)),\n              nc = Math.ceil(((measuredTemplate.data.distance * 1.5) / d.distance) / (d.size / grid.w))\n\n            // Get the center of the grid position occupied by the template\n            let x = measuredTemplate.data.x,\n              y = measuredTemplate.data.y\n\n            let [cx, cy] = grid.getCenter(x, y),\n              [col0, row0] = grid.grid.getGridPositionFromPixels(cx, cy),\n              minAngle = (360 + ((measuredTemplate.data.direction - measuredTemplate.data.angle * 0.5) % 360)) % 360,\n              maxAngle = (360 + ((measuredTemplate.data.direction + measuredTemplate.data.angle * 0.5) % 360)) % 360\n\n            const within_angle = function (min, max, value) {\n              min = (360 + min % 360) % 360\n              max = (360 + max % 360) % 360\n              value = (360 + value % 360) % 360\n\n              if (min < max) return (value >= min && value <= max)\n              return (value >= min || value <= max)\n            }\n\n            const measureDistance = function (p0, p1) {\n              let gs = canvas.dimensions.size,\n                ray = new Ray(p0, p1),\n                // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n                nx = Math.ceil(Math.abs(ray.dx / gs)),\n                ny = Math.ceil(Math.abs(ray.dy / gs))\n\n              // Get the number of straight and diagonal moves\n              let nDiagonal = Math.min(nx, ny),\n                nStraight = Math.abs(ny - nx)\n\n              // Diagonals in PF pretty much count as 1.5 times a straight\n              let distance = Math.floor(nDiagonal * 1.5 + nStraight)\n              let distanceOnGrid = distance * canvas.dimensions.distance\n              return distanceOnGrid\n            }\n\n            const degtorad = function (degrees) {\n              return degrees * Math.PI / 180\n            }\n\n            let originOffset = { x: 0, y: 0 }\n            // Offset measurement for cones\n            // Offset is to ensure that cones only start measuring from cell borders, as in https://www.d20pfsrd.com/magic/#Aiming_a_Spell\n            if (measuredTemplate.data.t === \"cone\") {\n              // Degrees anticlockwise from pointing right. In 45-degree increments from 0 to 360\n              const dir = (measuredTemplate.data.direction >= 0 ? 360 - measuredTemplate.data.direction : -measuredTemplate.data.direction) % 360\n              // If we're not on a border for X, offset by 0.5 or -0.5 to the border of the cell in the direction we're looking on X axis\n              let xOffset = measuredTemplate.data.x % d.size != 0 ?\n                Math.sign(1 * (Math.round(Math.cos(degtorad(dir)) * 100)) / 100) / 2 // /2 turns from 1/0/-1 to 0.5/0/-0.5\n                : 0\n              // Same for Y, but cos Y goes down on screens, we invert\n              let yOffset = measuredTemplate.data.y % d.size != 0 ?\n                -Math.sign(1 * (Math.round(Math.sin(degtorad(dir)) * 100)) / 100) / 2\n                : 0\n              originOffset.x = xOffset\n              originOffset.y = yOffset\n            }\n\n            // Point we are measuring distances from\n            let origin = {\n              x: measuredTemplate.data.x + (originOffset.x * d.size),\n              y: measuredTemplate.data.y + (originOffset.y * d.size)\n            }\n\n            for (let a = -nc; a < nc; a++) {\n              for (let b = -nr; b < nr; b++) {\n                // Position of cell's top-left corner, in pixels\n                let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(col0 + a, row0 + b)\n                // Position of cell's center, in pixels\n                let [cellCenterX, cellCenterY] = [gx + d.size * 0.5, gy + d.size * 0.5]\n\n                // Determine point of origin\n                let origin = { x: measuredTemplate.data.x, y: measuredTemplate.data.y }\n                origin.x += (originOffset.x * d.size)\n                origin.y += (originOffset.y * d.size)\n\n                let ray = new Ray(origin, { x: cellCenterX, y: cellCenterY })\n\n                let rayAngle = (360 + (ray.angle / (Math.PI / 180)) % 360) % 360\n                if (measuredTemplate.data.t === \"cone\" && ray.distance > 0 && !within_angle(minAngle, maxAngle, rayAngle)) {\n                  continue\n                }\n\n                // Determine point we're measuring the distance to - always in the center of a grid square\n                let destination = { x: cellCenterX, y: cellCenterY }\n\n                let distance = measureDistance(destination, origin)\n                if (distance <= measuredTemplate.data.distance) {\n                  grid.grid.highlightGridPosition(highlighter, { x: gx, y: gy, color: fc, border: bc })\n                }\n              }\n            }\n          } else {\n            /*\n            ----------- THX TO FOUNDRY CREATOR FOR THIS CODE FROM CORE FOUNDRY. --------------\n            */\n            // Get number of rows and columns\n            const nr = Math.ceil(((measuredTemplate.data.distance * 1.5) / d.distance) / (d.size / grid.h));\n            const nc = Math.ceil(((measuredTemplate.data.distance * 1.5) / d.distance) / (d.size / grid.w));\n            // Get the offset of the template origin relative to the top-left grid space\n            const [tx, ty] = canvas.grid.getTopLeft(measuredTemplate.data.x, measuredTemplate.data.y);\n            const [row0, col0] = grid.grid.getGridPositionFromPixels(tx, ty);\n            const hx = canvas.grid.w / 2;\n            const hy = canvas.grid.h / 2;\n            const isCenter = (measuredTemplate.data.x - tx === hx) && (measuredTemplate.data.y - ty === hy);\n            // Identify grid coordinates covered by the template Graphics\n            for (let r = -nr; r < nr; r++) {\n              for (let c = -nc; c < nc; c++) {\n                let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(row0 + r, col0 + c);\n                const testX = (gx + hx) - measuredTemplate.data.x;\n                const testY = (gy + hy) - measuredTemplate.data.y;\n                let contains = ((r === 0) && (c === 0) && isCenter) || measuredTemplate.shape.contains(testX, testY);\n                if (!contains) continue;\n                grid.grid.highlightGridPosition(highlighter, { x: gx, y: gy, color: fc, border: bc });\n              }\n            }\n          }\n        }\n\n        /*\n        ----------- THX TO FOUNDRY CREATOR FOR THIS CODE FROM DND 5. --------------\n        */\n\n        // Preview handlers\n        const handlers = {}\n        let moveTime = 0\n\n        // Update placement (mouse-move)\n        handlers.mm = event => {\n          event.stopPropagation()\n          let now = Date.now() // Apply a 20ms throttle\n          if (now - moveTime <= 20) return\n          const snapped = getTemplatePosition(event)\n          measuredTemplate.data.x = snapped.x\n          measuredTemplate.data.y = snapped.y\n          measuredTemplate.refresh()\n          highlightGrid()\n          moveTime = now\n        }\n\n        // Cancel the workflow (right-click)\n        handlers.rc = event => {\n          canvas.grid.destroyHighlightLayer(highlighterName)\n          measuredTemplate.layer.preview.removeChildren()\n          canvas.stage.off(\"mousemove\", handlers.mm)\n          canvas.stage.off(\"mousedown\", handlers.lc)\n          canvas.app.view.oncontextmenu = null\n          canvas.app.view.onwheel = null\n          initialLayer.activate()\n        }\n\n        // Confirm the workflow (left-click)\n        handlers.lc = event => {\n          handlers.rc(event)\n\n          const destination = getTemplatePosition(event)\n          measuredTemplate.data.x = destination.x\n          measuredTemplate.data.y = destination.y\n\n          canvas.scene.createEmbeddedEntity(\"MeasuredTemplate\", measuredTemplate.data)\n        }\n\n        // Rotate the template by 3 degree increments (mouse-wheel)\n        handlers.mw = event => {\n          if (event.ctrlKey) event.preventDefault()\n          event.stopPropagation()\n          let delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15\n          let snap = event.shiftKey ? delta : 5\n          measuredTemplate.data.direction += (snap * Math.sign(event.deltaY))\n          measuredTemplate.refresh()\n          highlightGrid()\n        }\n\n        // Activate listeners\n        canvas.stage.on(\"mousemove\", handlers.mm)\n        canvas.stage.on(\"mousedown\", handlers.lc)\n        canvas.app.view.oncontextmenu = handlers.rc\n        canvas.app.view.onwheel = handlers.mw\n      }\n    }\n  }\n}, {\n  id: 'pf2-template-creator'\n}).render(true)","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{}}
{"_id":"7RI3xjGsr8LuNSvd","name":"Modelo Area - Metros","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/circle.svg","scope":"global","command":"let applyChanges = false\nnew Dialog({\n  title: `Criador de modelos de área`,\n  content: `\n    <style>\n      #pf2-template-creator header {\n        border-radius: 0;\n        background: linear-gradient(90deg, var(--secondary) 0%, #202b93 50%, var(--secondary) 100%);\n        border: none;\n        box-shadow: inset 0 0 0 1px #9f725b,inset 0 0 0 2px var(--tertiary),inset 0 0 0 3px #956d58;\n        margin-bottom: 2px;\n        font-size: .75rem;\n      }\n      #pf2-template-creator .window-content {\n        background-image: url(systems/pf2e/assets/sheet/red_bg.jpg);\n        color: #ffefbd;\n        padding: 9px;\n        border-width: 9px;\n        border-image: url(systems/pf2e/assets/sheet/corner-box.png) 9 repeat;\n      }\n      #pf2-template-creator form {\n        margin-bottom: 20px;\n      }\n      #pf2-template-creator .form-fields.buttons {\n        justify-content: flex-start !important;\n      }\n      #pf2-template-creator .button {\n        flex: 1 !important;\n        border-width: 9px;\n        border-image: url(systems/pf2e/assets/sheet/corner-box.png) 9 repeat;\n        font-size: 12px;\n        padding: 0;\n        background: #171f69;\n        color: #ffefbd;\n        cursor: pointer;\n      }\n      #pf2-template-creator .button:hover {\n        box-shadow: 0 0 8px white;\n      }\n      #pf2-template-creator .radios input[type=\"radio\"] {\n        opacity: 0;\n        position: fixed;\n        width: 0;\n      }\n      #pf2-template-creator .radios label {\n        cursor: pointer;\n        display: flex;\n        flex: 1 !important;\n        margin: -2px 0;\n        background: rgba(0, 0, 0, 0.1);\n        border: 2px groove #f0f0e0;\n        width: 100%;\n        border-radius: 3px;\n        font-size: 13px;\n        font-family: \"Signika\", sans-serif;\n        justify-content: center;\n        align-items: center;\n        background: #171f69;\n        color: #ffefbd;\n        border-width: 9px;\n        border-image: url(systems/pf2e/assets/sheet/corner-box.png) 9 repeat;\n      }\n      #pf2-template-creator .radios label i {\n        margin-right: 5px;\n        color: #ffefbd;\n        background: #171f69;\n      }\n      #pf2-template-creator .radios label:hover {\n        box-shadow: 0 0 8px white;\n      }\n      #pf2-template-creator .radios input[type=\"radio\"]:checked + label {\n        background: rgba(0, 0, 0, 0.2);\n      }\n      #pf2-template-creator .dialog-button {\n        height: 50px;\n        background: #171f69;\n        border-image: url(systems/pf2e/assets/sheet/corner-box.png) 9 repeat;\n        color: #ffefbd;\n        border-width: 9px;\n        display: inline-flex;\n        justify-content: space-evenly;\n        align-items: center;\n        cursor: pointer;\n      }\n      #pf2-template-creator .notes {\n        color: #ffefbd !important;\n        flex: 0 0 100% !important;\n        font-size: 12px !important;\n        line-height: 16px !important;\n        margin: 10px 0 5px 0 !important;\n      }\n      #pf2-template-creator .notes.title {\n        border-bottom: 1px solid #f7d488;\n        font-size: 14px !important;\n        font-weight: bold;\n        margin: 20px 0 10px 0 !important;\n      }\n    </style>\n    <form>\n      <div class=\"form-group\">\n        <p class=\"notes title\">Tipo de zona:</p>\n        <div class=\"form-fields buttons radios\">\n          <input type=\"radio\" name=\"shape\" id=\"emanation\" value=\"emanation\" checked>\n          <label for=\"emanation\" onclick=\"toggleEmanationMessage(true)\"><i class=\"fas fa-square\"></i> Emanação</label>\n          <input type=\"radio\" name=\"shape\" id=\"burst\" value=\"burst\">\n          <label for=\"burst\" onclick=\"toggleEmanationMessage(false)\"><i class=\"fas fa-dot-circle\"></i> Explosão</label>\n          <input type=\"radio\" name=\"shape\" id=\"cone\" value=\"cone\">\n          <label for=\"cone\" onclick=\"toggleEmanationMessage(false)\"><i class=\"fas fa-wifi\"></i> Cone</label>\n          <input type=\"radio\" name=\"shape\" id=\"line\" value=\"line\">\n          <label for=\"line\" onclick=\"toggleEmanationMessage(false)\"><i class=\"fas fa-ruler-horizontal\"></i> Linha</label>\n        </div>\n      </div>\n\n      <div class=\"notes\" id=\"emanation-message\">\n        ${token ? `\n          ➡️ O modelo de Emanação será automaticamente colocado no token selecionado: ${token.data.name}.<br>\n          ${game[\"token-mold\"] ? `➡️ O modelo será movido com o token selecionado.` : `⚠️ Para que o modelo se mova com o token selecionado, instale e ative o módulo \"TokenMold\".`}\n        ` : `\n          ➡️ Para colocar automaticamente o modelo de Emanação em um token, execute esta macro com um token selecionado.\n        ` }\n      </div>\n\n      <div class=\"form-group\">\n        <p class=\"notes title\">Valores predefinidos:</p>\n        <div class=\"form-fields buttons\">\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(1.5)\">1.5 m</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(3)\">3 m</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(4.5)\">4.5 m</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(6)\">6 m</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(9)\">9 m</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(18)\">18 m</button>\n          <button type=\"button\" class=\"button\" onclick=\"updateRadiusValue(36)\">36 m</button>\n        </div>\n      </div>\n\n      <div class=\"form-group\">\n      <p class=\"notes title\">Raio do modelo em metros:</p>\n      <div class=\"form-fields\">\n        <input type=\"range\" id=\"radius\" name=\"radius\" value=\"1.5\" min=\"1.5\" max=\"36\" step=\"0.5\" oninput=\"updateRangeValue(this.value);\">\n        <span id=\"range-value\" class=\"range-value\">1.5</span>\n      </div>\n      </div>\n    </form>\n    <script>\n      function toggleEmanationMessage (isVisible) {\n        document.getElementById(\"emanation-message\").style.display = isVisible ? \"block\" : \"none\"\n      }\n      function updateRadiusValue(val) {\n        document.getElementById(\"radius\").value = val\n        updateRangeValue(val)\n      }\n      function updateRangeValue(val) {\n        document.getElementById(\"range-value\").innerHTML = val\n      }\n    </script>\n  `,\n  buttons: {\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancelar`\n    },\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Aplicar`,\n      callback: () => applyChanges = true\n    }\n  },\n  default: \"yes\",\n  close: html => {\n    if (applyChanges) {\n\n      // Template settings\n      const templateData = {\n        user: game.user._id,\n        distance: parseFloat(html.find('[name=\"radius\"]')[0].value),\n        direction: 0,\n        x: 0,\n        y: 0,\n        fillColor: game.user.color\n      }\n\n      let templateShape = html.find('[name=\"shape\"]')\n      for (var i = 0, length = templateShape.length; i < length; i++) {\n        if (templateShape[i].checked) {\n          templateShape = templateShape[i].value\n          break\n        }\n      }\n\n      switch (templateShape) {\n        case \"cone\":\n          templateData.t = \"cone\"\n          templateData.angle = 90\n          break\n        case \"emanation\":\n          templateData.t = \"circle\"\n          break\n        case \"line\":\n          templateData.t = \"ray\"\n          templateData.width = 1.5\n          break\n        case \"burst\":\n          templateData.t = \"circle\"\n          break\n        default:\n          break\n      }\n\n      const measuredTemplate = new MeasuredTemplate(templateData)\n\n      // If emanation shape then place template on token if token is selected\n      if (token && templateShape === \"emanation\") {\n        const shapeCenter = canvas.grid.getCenter(token.x, token.y)\n        measuredTemplate.data.x = shapeCenter[0]\n        measuredTemplate.data.y = shapeCenter[1]\n\n        const template = canvas.scene.createEmbeddedEntity(\"MeasuredTemplate\", measuredTemplate.data).then(template => {\n          // If tokenmold is installed and activated, stick the template to the token\n          if (game[\"token-mold\"]) {\n            let templateIds = duplicate(getProperty(token, \"data.flags.token-mold.sticky-templates.templateIds\") || [])\n            if (!templateIds.includes(template._id)) templateIds.push(template._id)\n            token.update({ \"flags.token-mold.sticky-templates.templateIds\": templateIds })\n          }\n        })\n      } else {\n        // Else prepare layer for preview\n        const highlighterName = 'Preview.' + Math.random().toString(36).substr(2, 9)\n        const highlighter = canvas.grid.addHighlightLayer(highlighterName)\n        const initialLayer = canvas.activeLayer\n        measuredTemplate.draw()\n        measuredTemplate.layer.activate()\n        measuredTemplate.layer.preview.addChild(measuredTemplate)\n\n        // Calculate the shape position\n        function getTemplatePosition(event) {\n          const center = event.data.getLocalPosition(measuredTemplate.layer)\n\n          if (templateShape === \"emanation\" || templateShape === \"line\") {\n            const shapeCenter = canvas.grid.getCenter(center.x, center.y)\n            return { x: shapeCenter[0], y: shapeCenter[1] }\n          } else if (templateShape === \"burst\") {\n            return canvas.grid.getSnappedPosition(center.x, center.y, 1)\n          } else if (templateShape === \"cone\") {\n            let shift = 0\n            const shapePosition = canvas.grid.getSnappedPosition(center.x, center.y, 2)\n            const centerPosition = canvas.grid.getCenter(shapePosition.x, shapePosition.y)\n            if (shapePosition.x === centerPosition[0] && shapePosition.y === centerPosition[1]) {\n              shapePosition.x += canvas.dimensions.size / 2\n            }\n            return shapePosition\n          } else {\n            return canvas.grid.getSnappedPosition(center.x, center.y, 2)\n          }\n        }\n\n        /*\n        ----------- THX TO PF2 SYSTEM CREATOR FOR THIS CODE. --------------\n        */\n\n        // Calculate the highlight\n        function highlightGrid() {\n          const grid = canvas.grid,\n            d = canvas.dimensions,\n            bc = \"0x000000\",\n            fc = measuredTemplate.data.fillColor.replace('#', '0x')\n\n          // Clear existing highlight\n          canvas.grid.clearHighlightLayer(highlighterName)\n          if ([\"circle\", \"cone\"].includes(measuredTemplate.data.t)) {\n            // Get number of rows and columns\n            let nr = Math.ceil(((measuredTemplate.data.distance * 1.5) / d.distance) / (d.size / grid.h)),\n              nc = Math.ceil(((measuredTemplate.data.distance * 1.5) / d.distance) / (d.size / grid.w))\n\n            // Get the center of the grid position occupied by the template\n            let x = measuredTemplate.data.x,\n              y = measuredTemplate.data.y\n\n            let [cx, cy] = grid.getCenter(x, y),\n              [col0, row0] = grid.grid.getGridPositionFromPixels(cx, cy),\n              minAngle = (360 + ((measuredTemplate.data.direction - measuredTemplate.data.angle * 0.5) % 360)) % 360,\n              maxAngle = (360 + ((measuredTemplate.data.direction + measuredTemplate.data.angle * 0.5) % 360)) % 360\n\n            const within_angle = function (min, max, value) {\n              min = (360 + min % 360) % 360\n              max = (360 + max % 360) % 360\n              value = (360 + value % 360) % 360\n\n              if (min < max) return (value >= min && value <= max)\n              return (value >= min || value <= max)\n            }\n\n            const measureDistance = function (p0, p1) {\n              let gs = canvas.dimensions.size,\n                ray = new Ray(p0, p1),\n                // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil\n                nx = Math.ceil(Math.abs(ray.dx / gs)),\n                ny = Math.ceil(Math.abs(ray.dy / gs))\n\n              // Get the number of straight and diagonal moves\n              let nDiagonal = Math.min(nx, ny),\n                nStraight = Math.abs(ny - nx)\n\n              // Diagonals in PF pretty much count as 1.5 times a straight\n              let distance = Math.floor(nDiagonal * 1.5 + nStraight)\n              let distanceOnGrid = distance * canvas.dimensions.distance\n              return distanceOnGrid\n            }\n\n            const degtorad = function (degrees) {\n              return degrees * Math.PI / 180\n            }\n\n            let originOffset = { x: 0, y: 0 }\n            // Offset measurement for cones\n            // Offset is to ensure that cones only start measuring from cell borders, as in https://www.d20pfsrd.com/magic/#Aiming_a_Spell\n            if (measuredTemplate.data.t === \"cone\") {\n              // Degrees anticlockwise from pointing right. In 45-degree increments from 0 to 360\n              const dir = (measuredTemplate.data.direction >= 0 ? 360 - measuredTemplate.data.direction : -measuredTemplate.data.direction) % 360\n              // If we're not on a border for X, offset by 0.5 or -0.5 to the border of the cell in the direction we're looking on X axis\n              let xOffset = measuredTemplate.data.x % d.size != 0 ?\n                Math.sign(1 * (Math.round(Math.cos(degtorad(dir)) * 100)) / 100) / 2 // /2 turns from 1/0/-1 to 0.5/0/-0.5\n                : 0\n              // Same for Y, but cos Y goes down on screens, we invert\n              let yOffset = measuredTemplate.data.y % d.size != 0 ?\n                -Math.sign(1 * (Math.round(Math.sin(degtorad(dir)) * 100)) / 100) / 2\n                : 0\n              originOffset.x = xOffset\n              originOffset.y = yOffset\n            }\n\n            // Point we are measuring distances from\n            let origin = {\n              x: measuredTemplate.data.x + (originOffset.x * d.size),\n              y: measuredTemplate.data.y + (originOffset.y * d.size)\n            }\n\n            for (let a = -nc; a < nc; a++) {\n              for (let b = -nr; b < nr; b++) {\n                // Position of cell's top-left corner, in pixels\n                let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(col0 + a, row0 + b)\n                // Position of cell's center, in pixels\n                let [cellCenterX, cellCenterY] = [gx + d.size * 0.5, gy + d.size * 0.5]\n\n                // Determine point of origin\n                let origin = { x: measuredTemplate.data.x, y: measuredTemplate.data.y }\n                origin.x += (originOffset.x * d.size)\n                origin.y += (originOffset.y * d.size)\n\n                let ray = new Ray(origin, { x: cellCenterX, y: cellCenterY })\n\n                let rayAngle = (360 + (ray.angle / (Math.PI / 180)) % 360) % 360\n                if (measuredTemplate.data.t === \"cone\" && ray.distance > 0 && !within_angle(minAngle, maxAngle, rayAngle)) {\n                  continue\n                }\n\n                // Determine point we're measuring the distance to - always in the center of a grid square\n                let destination = { x: cellCenterX, y: cellCenterY }\n\n                let distance = measureDistance(destination, origin)\n                if (distance <= measuredTemplate.data.distance) {\n                  grid.grid.highlightGridPosition(highlighter, { x: gx, y: gy, color: fc, border: bc })\n                }\n              }\n            }\n          } else {\n            /*\n            ----------- THX TO FOUNDRY CREATOR FOR THIS CODE FROM CORE FOUNDRY. --------------\n            */\n            // Get number of rows and columns\n            const nr = Math.ceil(((measuredTemplate.data.distance * 1.5) / d.distance) / (d.size / grid.h));\n            const nc = Math.ceil(((measuredTemplate.data.distance * 1.5) / d.distance) / (d.size / grid.w));\n            // Get the offset of the template origin relative to the top-left grid space\n            const [tx, ty] = canvas.grid.getTopLeft(measuredTemplate.data.x, measuredTemplate.data.y);\n            const [row0, col0] = grid.grid.getGridPositionFromPixels(tx, ty);\n            const hx = canvas.grid.w / 2;\n            const hy = canvas.grid.h / 2;\n            const isCenter = (measuredTemplate.data.x - tx === hx) && (measuredTemplate.data.y - ty === hy);\n            // Identify grid coordinates covered by the template Graphics\n            for (let r = -nr; r < nr; r++) {\n              for (let c = -nc; c < nc; c++) {\n                let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(row0 + r, col0 + c);\n                const testX = (gx + hx) - measuredTemplate.data.x;\n                const testY = (gy + hy) - measuredTemplate.data.y;\n                let contains = ((r === 0) && (c === 0) && isCenter) || measuredTemplate.shape.contains(testX, testY);\n                if (!contains) continue;\n                grid.grid.highlightGridPosition(highlighter, { x: gx, y: gy, color: fc, border: bc });\n              }\n            }\n          }\n        }\n\n        /*\n        ----------- THX TO FOUNDRY CREATOR FOR THIS CODE FROM DND 5. --------------\n        */\n\n        // Preview handlers\n        const handlers = {}\n        let moveTime = 0\n\n        // Update placement (mouse-move)\n        handlers.mm = event => {\n          event.stopPropagation()\n          let now = Date.now() // Apply a 20ms throttle\n          if (now - moveTime <= 20) return\n          const snapped = getTemplatePosition(event)\n          measuredTemplate.data.x = snapped.x\n          measuredTemplate.data.y = snapped.y\n          measuredTemplate.refresh()\n          highlightGrid()\n          moveTime = now\n        }\n\n        // Cancel the workflow (right-click)\n        handlers.rc = event => {\n          canvas.grid.destroyHighlightLayer(highlighterName)\n          measuredTemplate.layer.preview.removeChildren()\n          canvas.stage.off(\"mousemove\", handlers.mm)\n          canvas.stage.off(\"mousedown\", handlers.lc)\n          canvas.app.view.oncontextmenu = null\n          canvas.app.view.onwheel = null\n          initialLayer.activate()\n        }\n\n        // Confirm the workflow (left-click)\n        handlers.lc = event => {\n          handlers.rc(event)\n\n          const destination = getTemplatePosition(event)\n          measuredTemplate.data.x = destination.x\n          measuredTemplate.data.y = destination.y\n\n          canvas.scene.createEmbeddedEntity(\"MeasuredTemplate\", measuredTemplate.data)\n        }\n\n        // Rotate the template by 3 degree increments (mouse-wheel)\n        handlers.mw = event => {\n          if (event.ctrlKey) event.preventDefault()\n          event.stopPropagation()\n          let delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15\n          let snap = event.shiftKey ? delta : 5\n          measuredTemplate.data.direction += (snap * Math.sign(event.deltaY))\n          measuredTemplate.refresh()\n          highlightGrid()\n        }\n\n        // Activate listeners\n        canvas.stage.on(\"mousemove\", handlers.mm)\n        canvas.stage.on(\"mousedown\", handlers.lc)\n        canvas.app.view.oncontextmenu = handlers.rc\n        canvas.app.view.onwheel = handlers.mw\n      }\n    }\n  }\n}, {\n  id: 'pf2-template-creator'\n}).render(true)","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{}}
{"name":"Rest for the Night","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/sleep.svg","scope":"global","command":"game.pf2e.actions.restForTheNight({ actors: [token?.actor ?? actor ?? game.user.character].filter((actor) => actor) })","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Compendium.pf2e.pf2e-macros.0GU2sdy3r2MeC56x"}},"_id":"CiEnQIIAU3emauix"}
{"name":"Open Compendium Browser","type":"script","author":"IcM50v5xO4XDrGqp","img":"systems/pf2e/icons/equipment/adventuring-gear/advanced-book-of-translation.webp","scope":"global","command":"game.pf2e.compendiumBrowser.render(true);","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Compendium.pf2e.pf2e-macros.s2sa8lo9dcIA6UGe"}},"_id":"DEI023KSOin335oi"}
{"name":"XP","type":"script","author":"IcM50v5xO4XDrGqp","img":"systems/pf2e/icons/spells/athletic-rush.webp","scope":"global","command":"/**\n * @typedef {{data: {data: {details: {level: number|string|undefined|null, isComplex: boolean}}, type: string}}} Hazard\n */\n\n/**\n * @param actors {Array<Hazard>}\n * @param type {string}\n * @returns {Array<HazardLevel>}\n */\nfunction getHazardLevels(actors) {\n    return actors.filter((a) => a.data.type === \"hazard\");\n}\n\n/**\n * @typedef {{data: {data: {details: {level: {value: number|string|undefined|null}}}, type: string}}} Actor\n */\n\n/**\n * @param actors {Array<Actor>}\n * @param type {string}\n * @returns {Array<number>}\n */\nfunction getLevels(actors, type) {\n    return actors.filter((a) => a.data.type === type).map((a) => parseInt(a.data.data.details.level.value ?? \"1\", 10));\n}\n\n/**\n * @param xp {XP}\n * @returns {string}\n */\nfunction dialogTemplate(xp) {\n    return `\n<h2>XP</h2>\n<table>\n    <tr>\n        <th>Party</th>\n        <td>PCs: ${xp.partySize} (Lv ${xp.partyLevel})</td>\n    </tr>\n    <tr>\n        <th>Rating</th>\n        <td>${xp.rating} (${xp.xpPerPlayer} XP)</td>\n    </tr>\n    <tr>\n        <th>Reward</th>\n        <td>${xp.encounterBudgets.moderate} XP</td>\n    </tr>\n</table>\n<h2>Budgets</h2>\n<table>\n    <tr>\n        <th>Trivial</th>\n        <td>${xp.encounterBudgets.trivial} XP</td>\n    </tr>\n    <tr>\n        <th>Low</th>\n        <td>${xp.encounterBudgets.low} XP</td>\n    </tr>\n    <tr>\n        <th>Moderate</th>\n        <td>${xp.encounterBudgets.moderate} XP</td>\n    </tr>\n    <tr>\n        <th>Severe</th>\n        <td>${xp.encounterBudgets.severe} XP</td>\n    </tr>\n    <tr>\n        <th>Extreme</th>\n        <td>${xp.encounterBudgets.extreme} XP</td>\n    </tr>\n</table>`;\n}\n\nconst askLevelPopupTemplate = () => {\n    const partySize = parseInt(localStorage.getItem(\"xpMacroPartySize\") ?? 4, 10);\n    const partyLevel = parseInt(localStorage.getItem(\"xpMacroPartyLevel\") ?? 1, 10);\n    return `\n    <form>\n    <div class=\"form-group\">\n        <label>Party Size</label>\n        <input id=\"party-size\" name=\"party-size\" type=\"number\" value=\"${partySize}\">\n    </div>\n    <div class=\"form-group\">\n        <label>Party level</label>\n        <input id=\"party-level\" name=\"party-level\" type=\"number\" value=\"${partyLevel}\">\n    </div>\n    </form>\n    `;\n};\n\n/**\n * @param partyLevel {number}\n * @param partySize {number}\n * @param npcLevels {Array<number>}\n * @param hazardLevels {Array<HazardLevel>}\n */\nfunction showXP(partyLevel, partySize, npcLevels, hazardLevels) {\n    const xp = game.pf2e.gm.calculateXP(partyLevel, partySize, npcLevels, hazardLevels, {\n        proficiencyWithoutLevel: game.settings.get(\"pf2e\", \"proficiencyVariant\") === \"ProficiencyWithoutLevel\",\n    });\n    new Dialog({\n        title: \"XP\",\n        content: dialogTemplate(xp),\n        buttons: {},\n    }).render(true);\n}\n\n/**\n * @param npcLevels {Array<number>}\n * @param hazardLevels {Array<HazardLevel>}\n */\nfunction askPartyLevelAndSize(npcLevels, hazardLevels) {\n    new Dialog({\n        title: \"Party Information\",\n        content: askLevelPopupTemplate,\n        buttons: {\n            no: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: \"Cancel\",\n            },\n            yes: {\n                icon: '<i class=\"fas fa-calculator\"></i>',\n                label: \"Calculate XP\",\n                callback: ($html) => {\n                    const partySize = parseInt($html[0].querySelector('[name=\"party-size\"]').value, 10) ?? 1;\n                    const partyLevel = parseInt($html[0].querySelector('[name=\"party-level\"]').value, 10) ?? 1;\n                    // persist for future uses\n                    localStorage.setItem(\"xpMacroPartySize\", partySize);\n                    localStorage.setItem(\"xpMacroPartyLevel\", partyLevel);\n                    showXP(partyLevel, partySize, npcLevels, hazardLevels);\n                },\n            },\n        },\n        default: \"yes\",\n    }).render(true);\n}\n\nfunction main() {\n    const actors = canvas.tokens.controlled.map((a) => a.actor);\n    const npcLevels = getLevels(actors, \"npc\");\n    const pcLevels = getLevels(actors, \"character\");\n    const hazardLevels = getHazardLevels(actors);\n    if (npcLevels.length === 0 && hazardLevels.length === 0) {\n        ui.notifications.error(`You must select at least one npc and/or hazard token and optionally all PC tokens`);\n        return;\n    }\n\n    if (pcLevels.length === 0) {\n        askPartyLevelAndSize(npcLevels, hazardLevels);\n    } else {\n        showXP(pcLevels[0], pcLevels.length, npcLevels, hazardLevels);\n    }\n}\n\nmain();","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Compendium.pf2e.pf2e-macros.MAHxEeGf31wqv3jp"}},"_id":"IDiSrFBopJVWuAZM"}
{"name":"Treat Wounds","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/regen.svg","scope":"global","command":"function CheckFeat(slug) {\n    if (token.actor.items.find((i) => i.data.data.slug === slug && i.type === \"feat\")) {\n        return true;\n    }\n    return false;\n}\nconst rollTreatWounds = async ({ DC, bonus, med, riskysurgery, mortalhealing }) => {\n    const options = actor.getRollOptions([\"all\", \"skill-check\", \"medicine\"]);\n    options.push(\"treat wounds\");\n    options.push(\"action:treat-wounds\");\n    const dc = {\n        value: DC,\n        visibility: \"all\",\n    };\n    if (riskysurgery || mortalhealing) {\n        dc.modifiers = {\n            success: \"one-degree-better\",\n        };\n    }\n    if (riskysurgery) {\n        options.push(\"risky-surgery\");\n    }\n    med.roll({\n        dc: dc,\n        event: event,\n        options: options,\n        callback: (roll) => {\n            let healFormula, successLabel;\n            const magicHands = CheckFeat(\"magic-hands\");\n            const bonusString = bonus > 0 ? `+ ${bonus}` : \"\";\n            if (roll.data.degreeOfSuccess === 3) {\n                healFormula = magicHands ? `32${bonusString}` : `4d8${bonusString}`;\n                successLabel = \"Critical Success\";\n            } else if (roll.data.degreeOfSuccess === 2) {\n                healFormula = magicHands ? `16${bonusString}` : `2d8${bonusString}`;\n                successLabel = \"Success\";\n            } else if (roll.data.degreeOfSuccess === 1) {\n                successLabel = \"Failure\";\n            } else if (roll.data.degreeOfSuccess === 0) {\n                healFormula = \"1d8\";\n                successLabel = \"Critical Failure\";\n            }\n            if (riskysurgery) {\n                ChatMessage.create({\n                    user: game.user.id,\n                    type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n                    flavor: `<strong>Damage Roll: Risky Surgery</strong>`,\n                    roll: new Roll(\"{1d8}[slashing]\").roll(),\n                    speaker: ChatMessage.getSpeaker(),\n                });\n            }\n            if (healFormula !== undefined) {\n                const healRoll = new Roll(`{${healFormula}}[healing]`).roll();\n                const rollType = roll.data.degreeOfSuccess > 1 ? \"Healing\" : \"Damage\";\n                ChatMessage.create({\n                    user: game.user.id,\n                    type: CONST.CHAT_MESSAGE_TYPES.ROLL,\n                    flavor: `<strong>${rollType} Roll: Treat Wounds</strong> (${successLabel})`,\n                    roll: healRoll,\n                    speaker: ChatMessage.getSpeaker(),\n                });\n            }\n        },\n    });\n};\nasync function applyChanges($html) {\n    for (const token of canvas.tokens.controlled) {\n        var med = token.actor.data.data.skills.med;\n        if (!med) {\n            ui.notifications.warn(`Token ${token.name} does not have the medicine skill`);\n            continue;\n        }\n        const { name } = token;\n        const mod = parseInt($html.find('[name=\"modifier\"]').val()) || 0;\n        const requestedProf = parseInt($html.find('[name=\"dc-type\"]')[0].value) || 1;\n        const riskysurgery = $html.find('[name=\"risky_surgery_bool\"]')[0]?.checked;\n        const mortalhealing = $html.find('[name=\"mortal_healing_bool\"]')[0]?.checked;\n        const skill = $html.find('[name=\"skill\"]')[0]?.value;\n        // Handle Rule Interpretation\n        if (game.user.isGM) {\n            await game.settings.set(\n                \"pf2e\",\n                \"RAI.TreatWoundsAltSkills\",\n                $html.find('[name=\"strict_rules\"]')[0]?.checked\n            );\n        }\n        var usedProf = 0;\n        if (game.settings.get(\"pf2e\", \"RAI.TreatWoundsAltSkills\")) {\n            if (skill === \"cra\") {\n                med = token.actor.data.data.skills[\"cra\"];\n            }\n            if (skill === \"nat\") {\n                med = token.actor.data.data.skills[\"nat\"];\n            }\n            usedProf = requestedProf <= med.rank ? requestedProf : med.rank;\n        } else {\n            usedProf = requestedProf <= med.rank ? requestedProf : med.rank;\n            if (skill === \"cra\") {\n                med = token.actor.data.data.skills[\"cra\"];\n            }\n            if (skill === \"nat\") {\n                med = token.actor.data.data.skills[\"nat\"];\n                if (usedProf === 0) {\n                    usedProf = 1;\n                }\n            }\n        }\n        const medicBonus = CheckFeat(\"medic-dedication\") ? (usedProf - 1) * 5 : 0;\n        const roll = [\n            () => ui.notifications.warn(`${name} is not trained in Medicine and doesn't know how to treat wounds.`),\n            () => rollTreatWounds({ DC: 15 + mod, bonus: 0 + medicBonus, med, riskysurgery, mortalhealing }),\n            () => rollTreatWounds({ DC: 20 + mod, bonus: 10 + medicBonus, med, riskysurgery, mortalhealing }),\n            () => rollTreatWounds({ DC: 30 + mod, bonus: 30 + medicBonus, med, riskysurgery, mortalhealing }),\n            () => rollTreatWounds({ DC: 40 + mod, bonus: 50 + medicBonus, med, riskysurgery, mortalhealing }),\n        ][usedProf];\n        roll();\n    }\n}\nif (token === undefined) {\n    ui.notifications.warn(\"No token is selected.\");\n} else {\n    const chirurgeon = CheckFeat(\"chirurgeon\");\n    const naturalMedicine = CheckFeat(\"natural-medicine\");\n    const dialog = new Dialog({\n        title: \"Treat Wounds\",\n        content: `\n<div>Select a target DC. Remember that you can't attempt a heal above your proficiency. Attempting to do so will downgrade the DC and amount healed to the highest you're capable of.</div>\n<hr/>\n${\n    chirurgeon || naturalMedicine\n        ? `\n<form>\n<div class=\"form-group\">\n<label>Treat Wounds Skill:</label>\n<select id=\"skill\" name=\"skill\">\n<option value=\"med\">Medicine</option>\n${chirurgeon ? `<option value=\"cra\">Crafting</option>` : ``}\n${naturalMedicine ? `<option value=\"nat\">Nature</option>` : ``}\n</select>\n</div>\n</form>\n`\n        : ``\n}\n<form>\n<div class=\"form-group\">\n<label>Medicine DC:</label>\n<select id=\"dc-type\" name=\"dc-type\">\n<option value=\"1\">Trained DC 15</option>\n<option value=\"2\">Expert DC 20, +10 Healing</option>\n<option value=\"3\">Master DC 30, +30 Healing</option>\n<option value=\"4\">Legendary DC 40, +50 Healing</option>\n</select>\n</div>\n</form>\n<form>\n<div class=\"form-group\">\n<label>DC Modifier:</label>\n<input id=\"modifier\" name=\"modifier\" type=\"number\"/>\n</div>\n</form>\n${\n    CheckFeat(\"risky-surgery\")\n        ? `<form><div class=\"form-group\">\n<label>Risky Surgery</label>\n<input type=\"checkbox\" id=\"risky_surgery_bool\" name=\"risky_surgery_bool\"></input>\n</div></form>`\n        : ``\n}\n${\n    CheckFeat(\"mortal-healing\")\n        ? `<form><div class=\"form-group\">\n<label>Mortal Healing</label>\n<input type=\"checkbox\" id=\"mortal_healing_bool\" name=\"mortal_healing_bool\" checked></input>\n</div></form>`\n        : ``\n}\n${\n    game.user.isGM\n        ? `<form><div class=\"form-group\">\n<label>Allow higher DC from alternate skills?</label>\n<input type=\"checkbox\" id=\"strict_rules\" name=\"strict_rules\"` +\n          (game.settings.get(\"pf2e\", \"RAI.TreatWoundsAltSkills\") ? ` checked` : ``) +\n          `></input>\n</div></form>`\n        : ``\n}\n</form>\n`,\n        buttons: {\n            yes: {\n                icon: `<i class=\"fas fa-hand-holding-medical\"></i>`,\n                label: \"Treat Wounds\",\n                callback: applyChanges,\n            },\n            no: {\n                icon: `<i class=\"fas fa-times\"></i>`,\n                label: \"Cancel\",\n            },\n        },\n        default: \"yes\",\n    });\n    dialog.render(true);\n}","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Compendium.pf2e.pf2e-macros.6duZj0Ygiqv712rq"}},"_id":"NDGO2vzqRlIIUeI0"}
{"_id":"QwWHTUDywVQS9kKu","name":"Hidden / Greater Cover","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/mystery-man-black.svg","scope":"global","command":"// A macro for Pathfinder 2e to toggle greater cover. Written by @mistamichal5724  \n\nif (token.data.effects.includes(\"systems/pf2e/icons/conditions-2/hidden.png\")) { \n  actor.removeCustomModifier('ac', 'Greater cover') \n  token.toggleEffect(\"systems/pf2e/icons/conditions-2/hidden.png\") \n} else { \n  actor.addCustomModifier('ac', 'Greater cover', 4, 'circumstance'); \n  token.toggleEffect(\"systems/pf2e/icons/conditions-2/hidden.png\") \n};","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{}}
{"_id":"aTprDNa0VJCd5LFt","name":"All Initiative","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/combat.svg","scope":"global","command":"/* All tokens to Combat v1.3\n* - This macro select all tokens in the scene\n* - Add all of them to the combat tracker\n* - Roll Initiave for all\n* modified from @atnoslen with a little help from @Atropos (thanks!) \n* source: https://raw.githubusercontent.com/brunocalado/mestre-digital/master/Foundry%20VTT/Macros/Qualquer/Tokens%20da%20Cena%20no%20Combate.js\n* icon: https://raw.githubusercontent.com/brunocalado/mestre-digital/master/Foundry%20VTT/Macros/Qualquer/Tokens%20da%20Cena%20no%20Combate.svg\n*/\n\ngetRequirements();\n\nfunction getRequirements() {\n  const scene = game.scenes.entities.filter(scene => scene.active === true)[0];\n  let tokens_list = [];\n  scene.data.tokens.forEach(function(token) {\n    tokens_list += `<li>${token.name}</li>`;\n  });\n    \n  let template = `\n  <h2>Tokens</h2>\n  <ul>\n    ${tokens_list}\n  </ul>    \n  <h2>Opções</h2>\n  <table style=\"width:100%\">\n  <tr>\n    <td><input type=\"radio\" id=\"rollall\" name=\"rolltype\" value=\"rollall\"><label for=\"rollall\">Rolar para Todos?</label></td>\n    <td><input type=\"radio\" id=\"rollnpc\" name=\"rolltype\" value=\"rollnpc\" checked=\"checked><label for=\"rollnpc\">Rolar apenas para NPC?</label></td>    \n  </tr>\n  </table>  \n  <p>\n  <input type=\"checkbox\" id=\"startcombat\" checked/>Iniciar Combate?\n  </p>\n  `;\n  new Dialog({\n    title: \"Todo Mundo para o Combate\",\n    content: template,\n    buttons: {\n      ok: {\n        label: \"Manda Pau!\",\n        callback: async (html) => {\n          rollForIt(html);\n        },\n      }\n    },\n  }).render(true);\n}\n\nfunction rollForIt(html) {\n  const dice=html.find('input[name=\"rolltype\"]:checked').val();\n  let flagstartcombat=html.find(\"#startcombat\")[0].checked;\n  \n  const scene = game.scenes.entities.filter(scene => scene.active === true)[0];\n  let tokens = [];\n\n  let startCRoll=function rollAndStart() {\n    if(dice=='rollall') {\n      game.combat.rollAll();\n    } else {\n      game.combat.rollNPC();\n    }      \n    if (flagstartcombat) {\n      game.combat.startCombat();\n    }\n  }\n\n  if (!game.combat){\n    scene.data.tokens.forEach(function(token) {\n      tokens.push({tokenId:token._id});\n    });\n\n    Combat.create({scene:scene.data._id, combatants:tokens}).then(startCRoll);\n\n  } else {\n    // Combat already exists, add the missing tokens.\n    // This assumes createCombatant is expensive, so create an array\n    // instead of calling individually.\n    scene.data.tokens.forEach(function(token) {\n      if (game.combat.combatants.filter(combatant => combatant.tokenId === token._id).length === 0) {\n        tokens.push({tokenId:token._id});\n      }\n    });\n\n    game.combat.createCombatant(tokens).then(startCRoll);\n  }\n}","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{}}
{"name":"Add Persistent Damage","type":"script","author":"IcM50v5xO4XDrGqp","img":"systems/pf2e/icons/features/classes/brutality.webp","scope":"global","command":"PF2EPersistentDamage.showDialog();","folder":null,"sort":0,"permission":{"default":1,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Compendium.pf2e-persistent-damage.pf2e-persistent-damage-macros.pwyjwfc6dyf73p7f"}},"_id":"cBYn7IFzTkmvyXDI"}
{"name":"Process Healing (Regen / Fast Healing)","type":"script","author":"IcM50v5xO4XDrGqp","img":"systems/pf2e/icons/spells/regeneration.webp","scope":"global","command":"PF2EPersistentDamage.processHealing(canvas.tokens.controlled);","folder":null,"sort":0,"permission":{"default":1,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Compendium.pf2e-persistent-damage.pf2e-persistent-damage-macros.mh3yl3kgkp8onnom"}},"_id":"gVDnBY0xQXHxKdv6"}
{"_id":"qkBJ7QR469vZDLav","name":"Distance Between Tokens","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/down.svg","scope":"global","command":"const euclidian = false; // true=Medida Euclidiana | false=Medida Não-Euclidiana\n\n\n/* Total Distance between two tokens. \nversion = 0.2\nFeatures\n- Leva em conta a altura.\n\nsource: https://raw.githubusercontent.com/brunocalado/mestre-digital/master/Foundry%20VTT/Macros/Qualquer/DistanciaEntreTokens.js\nicon: icons/sundries/documents/document-symbol-circle-brown.webp\n*/\n\n// ===================================\nconst token1 = canvas.tokens.controlled[0];\nconst token2 = canvas.tokens.controlled[1];\nif(!token1 || !token2) {\n  ui.notifications.error(\"Selecione dois tokens!\");\n} else {\n  let output;\n  let output_msg;\n  if (euclidian) {\n    output = tokenDistance(token1, token2);\n    output_msg = 'euclidiana';\n  } else {\n    output = tokenDistanceNonEuclidian(token1, token2);\n    output_msg = 'não-euclidiana';\n  }\n  ChatMessage.create({\n    content: `<h2>Distância</h2><p>A distância ${output_msg} entre <b>${token1.name}</b> e <b>${token2.name}</b> é <b style=\"color: red\">${output}</b>.</p>`\n  })  \n}\n\nfunction tokenDistance(token1, token2) {  \n  const gridUnits = game.scenes.entities.filter(scene => scene.active === true)[0].data.gridUnits;\n  let distance = canvas.grid.measureDistance(token1, token2);\n  let tmp;\n  if(token1.elevation !== token2.data.elevation) {\n    let h_diff = token2.data.elevation > token1.data.elevation \n      ? token2.data.elevation - token1.data.elevation \n      : token1.data.elevation - token2.data.elevation;\n    tmp = Math.sqrt(Math.pow(h_diff,2) + Math.pow(distance,2));\n    return Math.round(tmp) + ' ' + gridUnits;\n  } else {\n    return Math.round(distance) + ' ' + gridUnits;\n  }\n}\n\nfunction tokenDistanceNonEuclidian(token1, token2) {  \n  const gridUnits = game.scenes.entities.filter(scene => scene.active === true)[0].data.gridUnits;\n  const ray = new Ray(token1, token2);\n  const segments = [{ray}];\n  let distance = canvas.grid.measureDistances(segments,{gridSpaces:true})[0]\n\n  const heightDelta = Math.abs(token1.data.elevation - token2.data.elevation);\n      \n  distance = Math.max(distance, heightDelta);    \n  return distance + ' ' + gridUnits;\n  //ui.notifications.info(`${dist} ft apart`)  \n}","folder":null,"sort":0,"permission":{"default":0,"IcM50v5xO4XDrGqp":3},"flags":{}}
{"name":"Process Persistent Damage","type":"script","author":"IcM50v5xO4XDrGqp","img":"systems/pf2e/icons/conditions/persistentDamage.webp","scope":"global","command":"PF2EPersistentDamage.processPersistentDamage(canvas.tokens.controlled);","folder":null,"sort":0,"permission":{"default":1,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Compendium.pf2e-persistent-damage.pf2e-persistent-damage-macros.5q5mzf7s5omgtdsi"}},"_id":"rLciLiejQcBwqYGj"}
{"name":"Open GM Screen","type":"script","author":"IcM50v5xO4XDrGqp","img":"icons/svg/book.svg","scope":"global","command":"//Import !GM Screen to use.\nlet journal = game.journal.getName(\"!GM Screen\");\n\nif (journal.sheet.rendered) \n\n  journal.sheet.close();\n\nelse\n\n  journal.sheet.render(true)","folder":null,"sort":0,"permission":{"default":0,"J3ZkOtLWFhx41djE":3,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Macro.sF50zBlELpjTOfy4"}},"_id":"yTzS4ZagHPOFDxjs"}
{"name":"Raise a Shield","type":"script","author":"IcM50v5xO4XDrGqp","img":"systems/pf2e/icons/actions/raise-a-shield.webp","scope":"global","command":"game.pf2e.actions.raiseAShield({ actors: [token?.actor ?? actor ?? game.user.character].filter((actor) => actor) })","folder":null,"sort":0,"permission":{"default":1,"IcM50v5xO4XDrGqp":3},"flags":{"core":{"sourceId":"Compendium.pf2e.action-macros.4hfQEMiEOBbqelAh"}},"_id":"z95xXvD4iXNalJfP"}
